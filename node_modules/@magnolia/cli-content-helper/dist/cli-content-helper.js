var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import path from 'path';
import { fileURLToPath } from 'url';
import { PluginTemplate } from '@magnolia/cli-plugin-template';
import fs from 'fs-extra';
import inquirer from 'inquirer';
import { initI18n, modifyConfig, prepareLightModule, checkFlagsValue, validateName, CreateError, getRelativePathToMGNLConfig, validateAndResolvePrototype, } from '@magnolia/cli-helper';
import Handlebars from 'handlebars';
import pluralize from 'pluralize';
const __dirname = path.dirname(fileURLToPath(import.meta.url));
export const cliPrototypesPath = path.resolve(__dirname, 'resources/mgnl-cli-prototypes');
export let logger;
export let i18nInstance = {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    t(key, options) {
        return key;
    },
};
export default class ContentHelperPlugin extends PluginTemplate {
    constructor(args, context) {
        super();
        this.options = [];
        this.configUpdates = {
            sharedProps: {},
            pluginProps: {},
        };
        i18nInstance = initI18n('content-helper', 'translation', path.join(__dirname, 'lib/locales'));
        this.pluginArgs = args || {};
        this.context = context;
    }
    init(winstonLogger) {
        return __awaiter(this, void 0, void 0, function* () {
            logger = winstonLogger;
        });
    }
    start(options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.context === 'app' && !options.contentType) {
                options.contentType = true;
            }
            const params = yield this.validateAndResolveArgs(options);
            yield this.create(params);
        });
    }
    stop() {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    validateAndResolveArgs(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const name = validateName(this.context === 'app' ? 'app' : 'content-type');
            checkFlagsValue(this.options, options);
            const { lightModulePath, newLightModulesPath, newLightModule } = yield prepareLightModule(options, this.pluginArgs, logger);
            if (newLightModulesPath) {
                this.configUpdates.sharedProps.lightModulesPath =
                    getRelativePathToMGNLConfig(newLightModulesPath);
            }
            if (newLightModule) {
                this.configUpdates.pluginProps.lightModule = newLightModule;
            }
            const { prototype, prototypeDir, pluginUpdates } = yield validateAndResolvePrototype(options, this.pluginArgs, cliPrototypesPath, logger);
            this.configUpdates.pluginProps = Object.assign(Object.assign({}, this.configUpdates.pluginProps), pluginUpdates);
            return Object.assign(Object.assign({ name,
                lightModulePath,
                prototypeDir,
                prototype }, (options.app && { app: options.app })), (options.contentType && { contentType: options.contentType }));
        });
    }
    create(vars) {
        return __awaiter(this, void 0, void 0, function* () {
            const entity1Type = this.context;
            const entity2Type = this.context === 'app' ? 'contentType' : 'app';
            const { name, prototype, prototypeDir, lightModulePath, contentType, app, } = vars;
            const entity1 = name;
            let entity2 = contentType || app;
            const entity1File = path.join(lightModulePath, entity1Type + 's', entity1 + '.yaml');
            this.checkFileExistence(entity1File, entity1, entity1Type);
            const entity1Data = {
                name: entity1,
            };
            if (entity2) {
                const entity2Data = {
                    context: entity1,
                    name: '',
                };
                let createNew = false;
                if (entity2 === true) {
                    const answer = yield this.handlePrompt(entity1, entity2Type, lightModulePath);
                    entity2 = answer.name;
                    createNew = answer.createNew;
                }
                entity2Data.name = entity2;
                entity1Data.context = entity2;
                const entity2File = path.join(lightModulePath, entity2Type + 's', entity2 + '.yaml');
                if (createNew) {
                    this.checkFileExistence(entity2File, entity2, entity2Type);
                }
                if (!fs.existsSync(entity2File)) {
                    this.createEntity(entity2Type, prototypeDir, prototype, entity2Data, lightModulePath);
                }
            }
            else if (entity1Type === 'contentType') {
                const recommendedWorkspaceName = pluralize.plural(entity1);
                entity1Data.context = yield this.namePrompt(recommendedWorkspaceName, 'workspace');
            }
            this.createEntity(entity1Type, prototypeDir, prototype, entity1Data, lightModulePath);
            yield modifyConfig(this.configUpdates, this.getPluginName(), logger);
        });
    }
    createEntity(type, prototypeDir, prototype, data, lightModulePath) {
        const filePath = path.join(prototypeDir, prototype, `{{${type === 'app' ? 'app' : 'content-type'}-name}}.yaml`);
        if (!fs.existsSync(filePath)) {
            throw new CreateError(i18nInstance.t('error-prototype-file-does-not-exist', {
                path: filePath,
                fileName: path.basename(filePath),
            }));
        }
        const file = fs.readFileSync(filePath, 'utf8');
        const doc = Handlebars.compile(file)(data);
        const outputFilePath = path.join(lightModulePath, type + 's', data.name + '.yaml');
        fs.outputFileSync(outputFilePath, doc, 'utf8');
        logger.info(i18nInstance.t('info-file-created', {
            file: data.name,
            type: type === 'app' ? 'App' : 'Content-type',
            path: outputFilePath,
        }));
        if (type === 'app') {
            this.handleAppsTranslation(prototypeDir, prototype, data, lightModulePath);
        }
    }
    handleAppsTranslation(prototypeDir, prototype, data, lightModulePath) {
        const enI18nFilePath = path.join(prototypeDir, prototype, 'en.properties');
        if (!fs.existsSync(enI18nFilePath))
            return;
        const enI18nFile = fs.readFileSync(enI18nFilePath, 'utf8');
        const enI18nContent = Handlebars.compile(enI18nFile)(data);
        const lmI18nPath = path.join(lightModulePath, 'i18n');
        if (!fs.existsSync(lmI18nPath)) {
            fs.mkdirSync(lmI18nPath, { recursive: true });
        }
        const defaultFileName = `${path.normalize(lightModulePath).split(path.sep).pop()}-messages_en.properties`;
        const defaultLmI18nPath = path.join(lmI18nPath, defaultFileName);
        const propertiesFiles = fs
            .readdirSync(lmI18nPath)
            .filter((file) => file.endsWith('.properties'));
        if (propertiesFiles.length === 0) {
            fs.writeFileSync(defaultLmI18nPath, enI18nContent, 'utf8');
            logger.info(i18nInstance.t('info-i18n-created', {
                i18nFile: defaultLmI18nPath,
                name: data.name,
            }));
        }
        else {
            if (fs.existsSync(defaultLmI18nPath)) {
                fs.appendFileSync(defaultLmI18nPath, '\n' + enI18nContent, 'utf8');
                logger.info(i18nInstance.t('info-i18n-appended', {
                    i18nFile: defaultLmI18nPath,
                    name: data.name,
                }));
            }
            else {
                const englishFile = propertiesFiles.find((file) => file.endsWith('en.properties'));
                if (englishFile) {
                    const englishFilePath = path.join(lmI18nPath, englishFile);
                    fs.appendFileSync(englishFilePath, '\n' + enI18nContent, 'utf8');
                    logger.info(i18nInstance.t('info-i18n-appended', {
                        i18nFile: englishFilePath,
                        name: data.name,
                    }));
                }
                else {
                    fs.writeFileSync(defaultLmI18nPath, enI18nContent, 'utf8');
                    logger.info(i18nInstance.t('info-i18n-created', {
                        i18nFile: defaultLmI18nPath,
                        name: data.name,
                    }));
                }
            }
        }
    }
    handlePrompt(entity1Name, type, lightModulePath) {
        return __awaiter(this, void 0, void 0, function* () {
            const typePath = path.join(lightModulePath, type + 's');
            let filenames = [];
            if (fs.existsSync(typePath)) {
                filenames = [...fs.readdirSync(typePath), 'create new'];
                filenames = filenames.map((file) => file.split('.yaml')[0]);
            }
            if (filenames.length > 1) {
                const { name } = yield inquirer.prompt([
                    {
                        type: 'list',
                        name: 'name',
                        choices: filenames,
                        message: i18nInstance.t('inquirer-prompt-select-content', {
                            type: type === 'app' ? 'app' : 'content-type',
                        }),
                    },
                ]);
                if (name !== 'create new') {
                    return { name, createNew: false };
                }
            }
            let recommendedName = type === 'app'
                ? pluralize.plural(entity1Name)
                : pluralize.singular(entity1Name);
            if (filenames.includes(recommendedName)) {
                recommendedName = '';
            }
            const entity2Name = yield this.namePrompt(recommendedName, type);
            return { name: entity2Name, createNew: true };
        });
    }
    namePrompt(recommendedName, type) {
        return __awaiter(this, void 0, void 0, function* () {
            const { name } = yield inquirer.prompt([
                Object.assign(Object.assign({ type: 'input', required: true, name: 'name' }, (!!recommendedName && { default: recommendedName })), { message: i18nInstance.t('inquirer-prompt-name', {
                        type: type === 'contentType' ? 'content-type' : type,
                        recommended: type === 'contentType' ? 'singular' : 'plural',
                    }) }),
            ]);
            try {
                return validateName(type === 'contentType' ? 'content-type' : type, name);
            }
            catch (e) {
                logger.error(e.message);
                return yield this.namePrompt(recommendedName, type);
            }
        });
    }
    checkFileExistence(filePath, name, type) {
        if (fs.existsSync(filePath)) {
            throw new CreateError(i18nInstance.t('error-file-already-exists', {
                type: type === 'app' ? 'App' : 'Content-type',
                name,
                path: filePath,
            }));
        }
    }
    getPluginName() {
        return `Create${this.context === 'app' ? 'App' : 'ContentType'}Plugin`;
    }
}
