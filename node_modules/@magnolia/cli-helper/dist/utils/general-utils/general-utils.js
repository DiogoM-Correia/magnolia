import path from 'path';
import { i18nInstance } from '../i18n/i18n.js';
export const BEAUTIFY_OPTIONS = {
    indent_size: 2,
    end_with_newline: true,
    max_preserve_newlines: 2,
    keep_array_indentation: false,
    preserve_newlines: true,
    wrap_line_length: 40,
};
export class CreateError extends Error {
    constructor(message) {
        super(message);
        this.message = message;
    }
}
const split = (pathToSplit) => {
    if (pathToSplit.indexOf(path.sep) !== -1) {
        // clever trick with filter to get rid of unwanted separators found on http://stackoverflow.com/a/19888749, of course
        return pathToSplit.split(path.sep).filter(Boolean);
    }
    return pathToSplit.split('/').filter(Boolean);
};
export const stripLastSep = (pathToStrip) => {
    if (pathToStrip.endsWith(path.sep) || pathToStrip.endsWith('/')) {
        return pathToStrip.slice(0, -1);
    }
    return pathToStrip;
};
export const getAbsolutePath = (relativePath) => relativePath
    ? path.resolve(process.env.INIT_CWD || process.cwd(), relativePath)
    : relativePath;
const isFlag = (commanderOptions, value) => commanderOptions.some((it) => it.long === value || it.short === value);
export function checkFlagsValue(commanderOptions, options) {
    Object.keys(options).forEach((key) => {
        const value = options[key];
        if (isFlag(commanderOptions, value)) {
            const optionLong = '--' + key.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
            const option = commanderOptions.find((it) => it.long === optionLong);
            throw new CreateError(i18nInstance.t('error-option-param-is-flag', {
                option: option === null || option === void 0 ? void 0 : option.flags,
                value: value,
            }));
        }
    });
}
export function validateName(type, name) {
    const args = process.argv;
    if (!name) {
        if (args.length > 3) {
            name = args[3];
        }
        else {
            throw new CreateError(i18nInstance.t('error-name-required', { type }));
        }
    }
    const invalidChars = /[/\\:*?"<>|@]/;
    if (name.startsWith('-')) {
        throw new CreateError(i18nInstance.t('error-invalid-name-start', { type, name }));
    }
    if (name.length > 255) {
        throw new CreateError(i18nInstance.t('error-invalid-name-length', { type, name }));
    }
    if (invalidChars.test(name)) {
        throw new CreateError(i18nInstance.t('error-invalid-name', { type, name }));
    }
    return name;
}
export function getModuleName(pathToModule) {
    const splitPath = split(pathToModule);
    if (splitPath.length === 1) {
        // token after last slash is assumed to be module name
        return splitPath[0];
    }
    // assume last part is module name
    return splitPath[splitPath.length - 1];
}
export function prependNumbersToChoices(choices) {
    return choices.map((choice, index) => ({
        name: `${index + 1}) ${typeof choice === 'string' ? choice : choice.name}`,
        value: choice,
    }));
}
