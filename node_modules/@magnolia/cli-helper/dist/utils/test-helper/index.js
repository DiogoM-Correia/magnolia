/* eslint-disable no-console */
import path from 'path';
import { execa } from 'execa';
import fs from 'fs-extra';
import { dirSync } from 'tmp';
import { parse } from '@babel/parser';
import * as t from '@babel/types';
import _traverse from '@babel/traverse';
import _generate from '@babel/generator';
import {
	afterAll,
	afterEach,
	beforeAll,
	beforeEach,
	describe,
	expect,
	it,
} from '@jest/globals';
import stripAnsi from 'strip-ansi';

const traverse = _traverse.default;
const generate = _generate.default;

const rootDir = path.join(process.cwd(), 'tests');

export const DOWN = '\x1B[B';
export const ENTER = '\x0D';

const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

const getDisplayKey = (key) => {
	if (key === 'ENTER' || key === ENTER) return 'ENTER';
	if (key === 'DOWN' || key === DOWN) return 'DOWN';
	return key;
};

export async function executeCommand(
	command,
	inputs = [],
	cwd = process.cwd(),
	cb = undefined,
) {
	const [first, ...rest] = command.split(' ');
	const pluginProcess = execa(first, rest, {
		cwd,
		stdio: ['pipe', 'pipe', 'pipe'],
	});

	const processedInputs = inputs.flatMap((input) =>
		typeof input === 'string' && input !== DOWN && input !== ENTER
			? input.split('')
			: [input],
	);

	await sendInputsSequentially(pluginProcess, processedInputs);

	if (cb && typeof cb === 'function') {
		cb(pluginProcess);
	}

	try {
		const { stdout } = await pluginProcess;
		return stripAnsi(stdout);
	} catch (error) {
		if (error.stdout) {
			return stripAnsi(error.stdout);
		}
		return stripAnsi(error.stderr || error.message);
	}
}

async function sendInputsSequentially(
	pluginProcess,
	inputs,
	promptIndicator = '?',
) {
	for (const key of inputs) {
		await waitForPrompt(pluginProcess, promptIndicator, 5000);
		await delay(100);
		pluginProcess.stdin.write(key);
		console.log(`Using key: ${getDisplayKey(key)}`);
	}
}

function waitForPrompt(pluginProcess, promptIndicator = '?', timeout = 5000) {
	return new Promise((resolve) => {
		let resolved = false;
		const onData = (data) => {
			const output = stripAnsi(data.toString());
			console.log(output);
			if (!resolved && output.includes(promptIndicator)) {
				resolved = true;
				clearTimeout(timer);
				pluginProcess.stdout.off('data', onData);
				resolve();
			}
		};
		pluginProcess.stdout.on('data', onData);
		const timer = setTimeout(() => {
			if (!resolved) {
				resolved = true;
				pluginProcess.stdout.off('data', onData);
				console.log(
					`Timed out waiting for prompt "${promptIndicator}". Continuing... This may cause the test to fail...`,
				);
				resolve();
			}
		}, timeout);
	});
}

export function addArgsToPlugin(config, pluginName, args) {
	const plugin = config?._export?.plugins?.find(
		(plugin) => plugin.callee === pluginName,
	);
	if (plugin) {
		plugin.arguments[0] = { ...plugin.arguments[0], ...args };
	}
}

export function getPluginFromConfig(config, pluginName) {
	return config?._export?.plugins?.find(
		(plugin) => plugin.callee === pluginName,
	);
}

export function parseConfig(configPath) {
	function parseNode(node) {
		switch (node.type) {
			case 'StringLiteral':
			case 'NumericLiteral':
			case 'BooleanLiteral':
				return node.value;
			case 'Identifier':
				return node.name;
			case 'ArrayExpression':
				return node.elements.map(parseNode);
			case 'ObjectExpression':
				return Object.fromEntries(
					node.properties.map(({ key, value }) => [
						key.name || key.value,
						parseNode(value),
					]),
				);
			case 'NewExpression':
				return {
					type: 'NewExpression',
					callee: node.callee.name,
					arguments: node.arguments.map(parseNode),
				};
			default:
				return null;
		}
	}

	const config = { _imports: [], _export: {} };
	const ast = parse(fs.readFileSync(configPath, 'utf-8'), {
		sourceType: 'module',
	});

	traverse(ast, {
		ImportDeclaration({ node: { source, specifiers } }) {
			config._imports.push({
				source: source.value,
				specifiers: specifiers.map(({ local, imported }) => ({
					localName: local.name,
					importedName: imported?.name || 'default',
				})),
			});
		},
		ExportDefaultDeclaration({ node }) {
			config._export = parseNode(node.declaration);
		},
	});

	return config;
}

export function writeConfig(filePath, config) {
	const generateImportNodes = (imports) =>
		imports.map(({ source, specifiers }) =>
			t.importDeclaration(
				specifiers.map(({ localName, importedName }) =>
					importedName === 'default'
						? t.importDefaultSpecifier(t.identifier(localName))
						: t.importSpecifier(
								t.identifier(localName),
								t.identifier(importedName),
							),
				),
				t.stringLiteral(source),
			),
		);

	const generateExportNode = (value) => {
		if (typeof value === 'string') {
			return t.stringLiteral(value);
		} else if (typeof value === 'boolean') {
			return t.booleanLiteral(value);
		} else if (typeof value === 'number') {
			return t.numericLiteral(value);
		} else if (Array.isArray(value)) {
			return t.arrayExpression(value.map(generateExportNode));
		} else if (value && typeof value === 'object') {
			if (value.type === 'NewExpression') {
				return t.newExpression(
					t.identifier(value.callee),
					value.arguments.map(generateExportNode),
				);
			}
			return t.objectExpression(
				Object.entries(value).map(([key, val]) =>
					t.objectProperty(
						t.isValidIdentifier(key)
							? t.identifier(key)
							: t.stringLiteral(key),
						generateExportNode(val),
					),
				),
			);
		}
		return t.nullLiteral();
	};

	try {
		const importCode = generateImportNodes(config._imports)
			.map((node) => generate(node).code)
			.join('\n');
		const exportCode = generate(
			t.exportDefaultDeclaration(generateExportNode(config._export)),
		).code;
		fs.writeFileSync(filePath, `${importCode}\n${exportCode}`, 'utf-8');
	} catch (error) {
		console.error(`Error writing config file: ${error.message}`);
	}
}

export async function setupTestEnvironment() {
	const tmpDir = dirSync({
		tmpdir: path.join(rootDir),
		unsafeCleanup: true,
		mode: 0o755,
	});
	const tmpDirPath = tmpDir.name;
	const testDir = path.join(tmpDirPath, 'test');
	fs.ensureDirSync(testDir);
	process.chdir(testDir);

	// Initialize node project
	try {
		const setup = await execa('npm', ['init', '-y'], { cwd: testDir });
		console.log('`npm init -y` output:', setup.stdout);
	} catch (error) {
		console.error('Error during `npm init -y`:', error);
	}

	// Add mgnl script to package.json
	const pjProjectPath = path.join(testDir, 'package.json');
	const pjProjectContent = fs.readJSONSync(pjProjectPath, 'utf8');
	pjProjectContent.scripts.mgnl = 'node node_modules/@magnolia/cli';
	pjProjectContent.type = 'module';
	fs.writeFileSync(
		pjProjectPath,
		JSON.stringify(pjProjectContent, null, 2),
		'utf8',
	);

	// Install CLI
	try {
		const setup = await execa(
			'npm',
			['install', '@magnolia/cli@5', '--no-bin-links'],
			{ cwd: testDir },
		);
		console.log('`npm install @magnolia/cli@5` output:', setup.stdout);
	} catch (error) {
		console.error('Error during `npm install @magnolia/cli@5`:', error);
	}

	// Copy plugin and prepare plugin
	const origPluginLoc = path.join(rootDir, '..', 'dist');
	const destPluginLoc = path.join(tmpDirPath, 'plugin');
	fs.ensureDirSync(destPluginLoc);
	fs.copySync(origPluginLoc, destPluginLoc, { dereference: true });
	const pjPluginPath = path.join(destPluginLoc, 'package.json');
	const pjPluginContent = fs.readJSONSync(pjPluginPath, 'utf8');
	pjPluginContent.main = pjPluginContent.main.replace('dist/', '');
	fs.writeFileSync(
		pjPluginPath,
		JSON.stringify(pjPluginContent, null, 2),
		'utf8',
	);
	const pluginSource = pjPluginContent.name;

	// Install plugin
	try {
		const setup = await execa(
			'npm',
			['install', destPluginLoc, '--no-bin-links'],
			{ cwd: testDir },
		);
		console.log('`npm install plugin` output:', setup.stdout);
	} catch (error) {
		console.error('Error during `npm install plugin`:', error);
	}

	// Create light-modules
	const lightModulesPath = path.join(testDir, 'light-modules');
	const lightModulePath = path.join(lightModulesPath, 'my-lm');
	const lightModule2Path = path.join(lightModulesPath, 'my-lm2');
	const lightModule3Path = path.join(lightModulesPath, 'my-lm3');
	fs.ensureDirSync(lightModulesPath);
	fs.ensureDirSync(lightModulePath);
	fs.ensureDirSync(lightModule2Path);
	fs.ensureDirSync(lightModule3Path);

	const backupDir = path.join(tmpDirPath, 'backup');
	fs.ensureDirSync(backupDir);
	fs.copySync(lightModulesPath, backupDir, { dereference: true });

	const protoDir = path.join(tmpDirPath, 'proto');
	fs.ensureDirSync(protoDir);
	const customPrototypesPath = path.join(protoDir, 'custom-prototypes');
	fs.ensureDirSync(customPrototypesPath);
	const prototypeDefaultPath = path.join(customPrototypesPath, '_default');
	fs.ensureDirSync(prototypeDefaultPath);
	const prototype2Path = path.join(customPrototypesPath, 'prototype2');
	fs.ensureDirSync(prototype2Path);
	const prototype3Path = path.join(customPrototypesPath, 'prototype3');
	fs.ensureDirSync(prototype3Path);

	const mgnlConfigPath = path.join(testDir, 'mgnl.config.js');

	return {
		tmpDir,
		testDir,
		backupDir,
		protoDir,
		mgnlConfigPath,
		pluginSource,
		lightModules: {
			fullPath: lightModulesPath,
			relativePath: getRelativePath(testDir, lightModulesPath),
			options: {
				lm1: {
					name: path.basename(lightModulePath),
					fullPath: lightModulePath,
					relativePath: getRelativePath(testDir, lightModulePath),
				},
				lm2: {
					name: path.basename(lightModule2Path),
					fullPath: lightModule2Path,
					relativePath: getRelativePath(testDir, lightModule2Path),
				},
				lm3: {
					name: path.basename(lightModule3Path),
					fullPath: lightModule3Path,
					relativePath: getRelativePath(testDir, lightModule3Path),
				},
			},
		},
		customPrototypes: {
			fullPath: customPrototypesPath,
			relativePath: getRelativePath(testDir, customPrototypesPath),
			options: {
				_default: {
					name: path.basename(prototypeDefaultPath),
					fullPath: prototypeDefaultPath,
					relativePath: getRelativePath(
						testDir,
						prototypeDefaultPath,
					),
				},
				prototype2: {
					name: path.basename(prototype2Path),
					fullPath: prototype2Path,
					relativePath: getRelativePath(testDir, prototype2Path),
				},
				prototype3: {
					name: path.basename(prototype3Path),
					fullPath: prototype3Path,
					relativePath: getRelativePath(testDir, prototype3Path),
				},
			},
		},
	};
}

export function prepareConfig(mgnlConfigPath, pluginName, pluginSource) {
	fs.writeFileSync(
		mgnlConfigPath,
		`import ${pluginName} from '${pluginSource}'\n` +
			'export default {\n' +
			'  analytics: {\n' +
			'    enabled: false,\n' +
			'  },\n' +
			'  plugins: [\n' +
			`    new ${pluginName}()\n` +
			'  ]\n' +
			'};',
		'utf8',
	);
}

export function cleanupTestEnvironment(tmpDir) {
	try {
		process.chdir(rootDir);
		tmpDir.removeCallback();
		console.log('Cleanup successful');
	} catch (e) {
		console.log(
			`Error occurred during cleanup: ${e.message}\nPlease delete the temporary folder manually: ${tmpDir.name}`,
		);
	}
}

export function resetTestEnvironment(testDir, backupDir) {
	const lightModulesPath = path.join(testDir, 'light-modules');
	fs.removeSync(lightModulesPath);
	fs.copySync(backupDir, lightModulesPath, { dereference: true });
}

export function assertConfig(
	mgnlConfigPath,
	pluginClassName,
	global = {},
	plugin = {},
) {
	const config = parseConfig(mgnlConfigPath);
	const globalConfig = config?._export;
	const pluginConfig = getPluginFromConfig(config, pluginClassName)
		?.arguments[0];

	expect(globalConfig?.lightModulesPath).toBe(global.lightModulesPath);
	expect(globalConfig?.lightModule).toBe(global.lightModule);
	expect(pluginConfig?.lightModule).toBe(plugin.lightModule);
	expect(pluginConfig?.prototypeDir).toBe(plugin.prototypeDir);
	expect(pluginConfig?.prototype).toBe(plugin.prototype);

	return {
		globalConfig,
		pluginConfig,
	};
}

export function getRelativePath(p1, p2) {
	const relativePath = path
		.normalize(path.relative(p1, p2))
		.replace(/\\/g, '/');
	return relativePath.startsWith('.') ? relativePath : './' + relativePath;
}

export function validateOutput(output, shouldContainError = false) {
	const lines = output.split('\n');
	const hasError = lines.some((line) => line.trim().startsWith('error:'));
	expect(hasError).toBe(shouldContainError);
}

export function addPluginInputs(inputs1, inputs2) {
	inputs1.push(...inputs2);
	return inputs1;
}

export function runDefaultTests(
	pluginClassName,
	pluginCommand,
	name,
	pluginInputs,
	assertFiles,
	preparePrototypes,
) {
	describe('MGNL CLI Plugins Default Tests', () => {
		const mgnlCommand = `npm run mgnl -- ${pluginCommand}`;
		let testEnv;

		beforeAll(async () => {
			testEnv = await setupTestEnvironment();
			preparePrototypes(testEnv);
		}, 100000);

		beforeEach(() => {
			prepareConfig(
				testEnv.mgnlConfigPath,
				pluginClassName,
				testEnv.pluginSource,
			);
		});

		afterEach(() => {
			resetTestEnvironment(testEnv.testDir, testEnv.backupDir);
		});

		afterAll(() => {
			cleanupTestEnvironment(testEnv.tmpDir);
		});

		/*
		 * Action: `<command>` should be available in Magnolia CLI's help output
		 */
		it("`<command>` should be available in Magnolia CLI's help output", async () => {
			/* Command */
			const output = await executeCommand(
				'npm run mgnl -- -h',
				addPluginInputs([], pluginInputs),
				testEnv.testDir,
			);

			/* Assertion */
			validateOutput(output);
			expect(output).toContain(pluginCommand);
		}, 15000);

		/*
		 * Action: Should run `<command>` with no predefined properties in mgnl.config.js
		 *
		 * Before:
		 *  - No predefined properties in mgnl.config.js
		 *
		 * During:
		 *  - Should prompt for:
		 *  -- 'Select directory with all light modules'
		 *  -- 'Select light module'
		 *
		 * After:
		 *  - Should add properties to mgnl.config.js:
		 *  -- global:
		 *  --- lightModulesPath (relative path)
		 *  -- plugin:
		 *  --- lightModule
		 */
		it('Should run `<command>` with no predefined properties mgnl.config.js', async () => {
			/* Command */
			const inputs = [
				// Choose directory with all light modules
				DOWN, // Move selection to: '..'
				DOWN, // Move selection to: 'light-modules'
				ENTER, // Confirm selection: 'light-modules'
				ENTER, // Confirm selection: 'Use this directory'
				// Choose light module
				'1', // Move selection to: '1) my-lm'
				ENTER, // Confirm selection: '1) my-lm'
			];
			const output = await executeCommand(
				`${mgnlCommand} ${name}`,
				addPluginInputs(inputs, pluginInputs),
				testEnv.testDir,
			);

			/* Assertion */
			validateOutput(output);
			assertFiles(testEnv.lightModules.options.lm1.fullPath);
			assertConfig(
				testEnv.mgnlConfigPath,
				pluginClassName,
				{ lightModulesPath: testEnv.lightModules.relativePath },
				{ lightModule: testEnv.lightModules.options.lm1.name },
			);
		}, 15000);

		/*
		 * Action: Should run `<command>` with predefined properties in mgnl.config.js (1)
		 *
		 * Before:
		 *  - Predefined properties in mgnl.config.js:
		 *  -- global:
		 *  --- lightModulesPath (relative path)
		 *
		 * During:
		 *  - Should prompt for:
		 *  -- 'Select light module'
		 *
		 * After:
		 *  - Should add properties to mgnl.config.js:
		 *  -- plugin:
		 *  --- lightModule
		 */
		it('Should run `<command>` with predefined properties in mgnl.config.js (1)', async () => {
			/* Setup */
			const configBefore = parseConfig(testEnv.mgnlConfigPath);
			configBefore._export.lightModulesPath =
				testEnv.lightModules.relativePath;
			writeConfig(testEnv.mgnlConfigPath, configBefore);

			/* Command */
			const inputs = [
				// Choose light module
				'1', // Move selection to: '1) my-lm'
				ENTER, // Confirm selection: '1) my-lm'
			];
			const output = await executeCommand(
				`${mgnlCommand} ${name}`,
				addPluginInputs(inputs, pluginInputs),
				testEnv.testDir,
			);

			/* Assertion */
			validateOutput(output);
			assertFiles(testEnv.lightModules.options.lm1.fullPath);
			assertConfig(
				testEnv.mgnlConfigPath,
				pluginClassName,
				{ lightModulesPath: testEnv.lightModules.relativePath },
				{ lightModule: testEnv.lightModules.options.lm1.name },
			);
		}, 15000);

		/*
		 * Action: Should run `<command>` with predefined properties in mgnl.config.js (2)
		 *
		 * Before:
		 *  - Predefined properties in mgnl.config.js:
		 *  -- global:
		 *  --- lightModulesPath (relative path)
		 *  --- lightModule
		 *
		 * During:
		 *
		 * After:
		 *
		 */
		it('Should run `<command>` with predefined properties in mgnl.config.js (2)', async () => {
			/* Setup */
			const lightModule = testEnv.lightModules.options.lm1.name; // my-lm

			const configBefore = parseConfig(testEnv.mgnlConfigPath);
			configBefore._export.lightModulesPath =
				testEnv.lightModules.relativePath;
			configBefore._export.lightModule = lightModule;
			writeConfig(testEnv.mgnlConfigPath, configBefore);

			/* Command */
			const output = await executeCommand(
				`${mgnlCommand} ${name}`,
				addPluginInputs([], pluginInputs),
				testEnv.testDir,
			);

			/* Assertion */
			validateOutput(output);
			assertFiles(testEnv.lightModules.options.lm1.fullPath);
			assertConfig(testEnv.mgnlConfigPath, pluginClassName, {
				lightModulesPath: testEnv.lightModules.relativePath,
				lightModule,
			});
		}, 15000);

		/*
		 * Action: Should run `<command>` with predefined properties in mgnl.config.js (3)
		 *
		 * Before:
		 *  - Predefined properties in mgnl.config.js:
		 *  -- global:
		 *  --- lightModulesPath (full path)
		 *  --- lightModule
		 *
		 * During:
		 *
		 * After:
		 *
		 */
		it('Should run `<command>` with predefined properties in mgnl.config.js (3)', async () => {
			/* Setup */
			const lightModule = testEnv.lightModules.options.lm1.name; // my-lm

			const configBefore = parseConfig(testEnv.mgnlConfigPath);
			configBefore._export.lightModulesPath =
				testEnv.lightModules.fullPath;
			configBefore._export.lightModule = lightModule;
			writeConfig(testEnv.mgnlConfigPath, configBefore);

			/* Command */
			const output = await executeCommand(
				`${mgnlCommand} ${name}`,
				addPluginInputs([], pluginInputs),
				testEnv.testDir,
			);

			/* Assertion */
			validateOutput(output);
			assertFiles(testEnv.lightModules.options.lm1.fullPath);
			assertConfig(testEnv.mgnlConfigPath, pluginClassName, {
				lightModulesPath: testEnv.lightModules.fullPath,
				lightModule,
			});
		}, 15000);

		/*
		 * Action: Should run `<command>` with predefined properties in mgnl.config.js (4)
		 *
		 * Before:
		 *  - Predefined properties in mgnl.config.js:
		 *  -- global:
		 *  --- lightModulesPath (relative path)
		 *  -- plugin:
		 *  --- lightModule
		 *
		 * During:
		 *
		 * After:
		 *
		 */
		it('Should run `<command>` with predefined properties in mgnl.config.js (4)', async () => {
			/* Setup */
			const lightModule = testEnv.lightModules.options.lm1.name; // my-lm

			const configBefore = parseConfig(testEnv.mgnlConfigPath);
			configBefore._export.lightModulesPath =
				testEnv.lightModules.relativePath;
			addArgsToPlugin(configBefore, pluginClassName, { lightModule });
			writeConfig(testEnv.mgnlConfigPath, configBefore);

			/* Command */
			const output = await executeCommand(
				`${mgnlCommand} ${name}`,
				addPluginInputs([], pluginInputs),
				testEnv.testDir,
			);

			/* Assertion */
			validateOutput(output);
			assertFiles(testEnv.lightModules.options.lm1.fullPath);
			assertConfig(
				testEnv.mgnlConfigPath,
				pluginClassName,
				{ lightModulesPath: testEnv.lightModules.relativePath },
				{ lightModule },
			);
		}, 15000);

		/*
		 * Action: Should run `<command>` with predefined properties in mgnl.config.js (5)
		 *
		 * Before:
		 *  - Predefined properties in mgnl.config.js:
		 *  -- global:
		 *  --- lightModulesPath (relative path)
		 *  --- lightModule
		 *  -- plugin:
		 *  --- lightModule
		 *
		 * During:
		 *
		 * After:
		 *
		 */
		it('Should run `<command>` with predefined properties in mgnl.config.js (5)', async () => {
			/* Setup */
			const lightModule = testEnv.lightModules.options.lm1.name; // my-lm
			const lightModule2 = testEnv.lightModules.options.lm2.name; // my-lm2

			const configBefore = parseConfig(testEnv.mgnlConfigPath);
			configBefore._export.lightModulesPath =
				testEnv.lightModules.relativePath;
			configBefore._export.lightModule = lightModule2;
			addArgsToPlugin(configBefore, pluginClassName, { lightModule });
			writeConfig(testEnv.mgnlConfigPath, configBefore);

			/* Command */
			const output = await executeCommand(
				`${mgnlCommand} ${name}`,
				addPluginInputs([], pluginInputs),
				testEnv.testDir,
			);

			/* Assertion */
			validateOutput(output);
			assertFiles(testEnv.lightModules.options.lm1.fullPath);
			assertConfig(
				testEnv.mgnlConfigPath,
				pluginClassName,
				{
					lightModulesPath: testEnv.lightModules.relativePath,
					lightModule: lightModule2,
				},
				{ lightModule },
			);
		}, 15000);

		/*
		 * Action: Should run `<command>` with predefined properties in mgnl.config.js (6)
		 *
		 * Before:
		 *  - Predefined properties in mgnl.config.js:
		 *  -- global:
		 *  --- lightModulesPath (relative path)
		 *  --- lightModule
		 *  -- plugin:
		 *  --- prototypeDir (relative path)
		 *
		 * During:
		 *
		 * After:
		 *
		 */
		it('Should run `<command>` with predefined properties in mgnl.config.js (6)', async () => {
			/* Setup */
			const lightModule = testEnv.lightModules.options.lm1.name; // my-lm

			const configBefore = parseConfig(testEnv.mgnlConfigPath);
			configBefore._export.lightModulesPath =
				testEnv.lightModules.relativePath;
			configBefore._export.lightModule = lightModule;
			addArgsToPlugin(configBefore, pluginClassName, {
				prototypeDir: testEnv.customPrototypes.relativePath,
			});
			writeConfig(testEnv.mgnlConfigPath, configBefore);

			/* Command */
			const output = await executeCommand(
				`${mgnlCommand} ${name}`,
				addPluginInputs([], pluginInputs),
				testEnv.testDir,
			);

			/* Assertion */
			validateOutput(output);
			assertFiles(testEnv.lightModules.options.lm1.fullPath, {
				customPrototype: true,
			});
			assertConfig(
				testEnv.mgnlConfigPath,
				pluginClassName,
				{
					lightModulesPath: testEnv.lightModules.relativePath,
					lightModule,
				},
				{ prototypeDir: testEnv.customPrototypes.relativePath },
			);
		}, 15000);

		/*
		 * Action: Should run `<command>` with predefined properties in mgnl.config.js (7)
		 *
		 * Before:
		 *  - Predefined properties in mgnl.config.js:
		 *  -- global:
		 *  --- lightModulesPath (relative path)
		 *  --- lightModule
		 *  -- plugin:
		 *  --- prototypeDir (full path)
		 *
		 * During:
		 *
		 * After:
		 *
		 */
		it('Should run `<command>` with predefined properties in mgnl.config.js (7)', async () => {
			/* Setup */
			const lightModule = testEnv.lightModules.options.lm1.name; // my-lm

			const configBefore = parseConfig(testEnv.mgnlConfigPath);
			configBefore._export.lightModulesPath =
				testEnv.lightModules.relativePath;
			configBefore._export.lightModule = lightModule;
			addArgsToPlugin(configBefore, pluginClassName, {
				prototypeDir: testEnv.customPrototypes.fullPath,
			});
			writeConfig(testEnv.mgnlConfigPath, configBefore);

			/* Command */
			const output = await executeCommand(
				`${mgnlCommand} ${name}`,
				addPluginInputs([], pluginInputs),
				testEnv.testDir,
			);

			/* Assertion */
			validateOutput(output);
			assertFiles(testEnv.lightModules.options.lm1.fullPath, {
				customPrototype: true,
			});
			assertConfig(
				testEnv.mgnlConfigPath,
				pluginClassName,
				{
					lightModulesPath: testEnv.lightModules.relativePath,
					lightModule,
				},
				{ prototypeDir: testEnv.customPrototypes.fullPath },
			);
		}, 15000);

		/*
		 * Action: Should run `<command>` with predefined properties in mgnl.config.js (8)
		 *
		 * Before:
		 *  - Predefined properties in mgnl.config.js:
		 *  -- global:
		 *  --- lightModulesPath (relative path)
		 *  --- lightModule
		 *  -- plugin:
		 *  --- prototypeDir (relative path)
		 *  --- prototype
		 *
		 * During:
		 *
		 * After:
		 *
		 */
		it('Should run `<command>` with predefined properties in mgnl.config.js (8)', async () => {
			/* Setup */
			const lightModule = testEnv.lightModules.options.lm1.name; // my-lm
			const prototype = testEnv.customPrototypes.options.prototype2.name; // prototype2

			const configBefore = parseConfig(testEnv.mgnlConfigPath);
			configBefore._export.lightModulesPath =
				testEnv.lightModules.relativePath;
			configBefore._export.lightModule = lightModule;
			addArgsToPlugin(configBefore, pluginClassName, {
				prototypeDir: testEnv.customPrototypes.relativePath,
			});
			addArgsToPlugin(configBefore, pluginClassName, { prototype });
			writeConfig(testEnv.mgnlConfigPath, configBefore);

			/* Command */
			const output = await executeCommand(
				`${mgnlCommand} ${name}`,
				addPluginInputs([], pluginInputs),
				testEnv.testDir,
			);

			/* Assertion */
			validateOutput(output);
			assertFiles(testEnv.lightModules.options.lm1.fullPath, {
				customPrototype: true,
				prototype,
			});
			assertConfig(
				testEnv.mgnlConfigPath,
				pluginClassName,
				{
					lightModulesPath: testEnv.lightModules.relativePath,
					lightModule,
				},
				{
					prototypeDir: testEnv.customPrototypes.relativePath,
					prototype,
				},
			);
		}, 15000);

		/*
		 * Action: Should run `<command>` with predefined properties in mgnl.config.js but incorrect value (1)
		 *
		 * Before:
		 *  - Predefined properties in mgnl.config.js:
		 *  -- global:
		 *  --- lightModulesPath (non existing path)
		 *  --- lightModule
		 *
		 * During:
		 *  - Should prompt for:
		 *  -- 'Select directory with all light modules'
		 *
		 * After:
		 *  - Should add properties to mgnl.config.js:
		 *  -- global:
		 *  --- lightModulesPath (change to existing path)
		 */
		it('Should run `<command>` with predefined properties in mgnl.config.js, but incorrect value (1)', async () => {
			/* Setup */
			const lightModule = testEnv.lightModules.options.lm1.name; // my-lm

			const configBefore = parseConfig(testEnv.mgnlConfigPath);
			configBefore._export.lightModulesPath = getRelativePath(
				testEnv.testDir,
				'incorrect',
			);
			configBefore._export.lightModule = lightModule;
			writeConfig(testEnv.mgnlConfigPath, configBefore);

			/* Command */
			const inputs = [
				// Choose directory with all light modules
				DOWN, // Move selection to: '..'
				DOWN, // Move selection to: 'light-modules'
				ENTER, // Confirm selection: 'light-modules'
				ENTER, // Confirm selection: 'Use this directory'
			];
			const output = await executeCommand(
				`${mgnlCommand} ${name}`,
				addPluginInputs(inputs, pluginInputs),
				testEnv.testDir,
			);

			/* Assertion */
			validateOutput(output);
			assertFiles(testEnv.lightModules.options.lm1.fullPath);
			assertConfig(testEnv.mgnlConfigPath, pluginClassName, {
				lightModulesPath: testEnv.lightModules.relativePath,
				lightModule,
			});
		}, 15000);

		/*
		 * Action: Should run `<command>` with predefined properties in mgnl.config.js but incorrect value (2)
		 *
		 * Before:
		 *  - Predefined properties in mgnl.config.js:
		 *  -- global:
		 *  --- lightModulesPath (relative path)
		 *  --- lightModule (non existing lm: "incorrect")
		 *
		 * During:
		 *  - Should prompt for:
		 *  -- 'Select light module'
		 *
		 * After:
		 *  - Should add properties to mgnl.config.js:
		 *  -- plugin:
		 *  --- lightModule
		 */
		it('Should run `<command>` with predefined properties in mgnl.config.js, but incorrect value (2)', async () => {
			/* Setup */
			const configBefore = parseConfig(testEnv.mgnlConfigPath);
			configBefore._export.lightModulesPath =
				testEnv.lightModules.relativePath;
			configBefore._export.lightModule = 'incorrect';
			writeConfig(testEnv.mgnlConfigPath, configBefore);

			/* Command */
			const inputs = [
				// Choose light module
				'1', // Move selection to: '1) my-lm'
				ENTER, // Confirm selection: '1) my-lm'
			];
			const output = await executeCommand(
				`${mgnlCommand} ${name}`,
				addPluginInputs(inputs, pluginInputs),
				testEnv.testDir,
			);

			/* Assertion */
			validateOutput(output);
			assertFiles(testEnv.lightModules.options.lm1.fullPath);
			assertConfig(
				testEnv.mgnlConfigPath,
				pluginClassName,
				{
					lightModulesPath: testEnv.lightModules.relativePath,
					lightModule: 'incorrect',
				},
				{ lightModule: testEnv.lightModules.options.lm1.name },
			);
		}, 15000);

		/*
		 * Action: Should run `<command>` with predefined properties in mgnl.config.js but incorrect value (3)
		 *
		 * Before:
		 *  - Predefined properties in mgnl.config.js:
		 *  -- global:
		 *  --- lightModulesPath (relative path)
		 *  -- plugin:
		 *  --- lightModule (non existing lm: "incorrect")
		 *
		 * During:
		 *  - Should prompt for:
		 *  -- 'Select light module'
		 *
		 * After:
		 *  - Should add properties to mgnl.config.js:
		 *  -- plugin:
		 *  --- lightModule (change from "incorrect" to "my-lm")
		 */
		it('Should run `<command>` with predefined properties in mgnl.config.js, but incorrect value (3)', async () => {
			/* Setup */
			const configBefore = parseConfig(testEnv.mgnlConfigPath);
			configBefore._export.lightModulesPath =
				testEnv.lightModules.relativePath;
			addArgsToPlugin(configBefore, pluginClassName, {
				lightModule: 'incorrect',
			});
			writeConfig(testEnv.mgnlConfigPath, configBefore);

			/* Command */
			const inputs = [
				// Choose light module
				'1', // Move selection to: '1) my-lm'
				ENTER, // Confirm selection: '1) my-lm'
			];
			const output = await executeCommand(
				`${mgnlCommand} ${name}`,
				addPluginInputs(inputs, pluginInputs),
				testEnv.testDir,
			);

			/* Assertion */
			validateOutput(output);
			assertFiles(testEnv.lightModules.options.lm1.fullPath);
			assertConfig(
				testEnv.mgnlConfigPath,
				pluginClassName,
				{ lightModulesPath: testEnv.lightModules.relativePath },
				{ lightModule: testEnv.lightModules.options.lm1.name },
			);
		}, 15000);

		/*
		 * Action: Should run `<command>` with predefined properties in mgnl.config.js, but incorrect value (4)
		 *
		 * Before:
		 *  - Predefined properties in mgnl.config.js:
		 *  -- global:
		 *  --- lightModulesPath (relative path)
		 *  --- lightModule
		 *  -- plugin:
		 *  --- prototypeDir (relative path)
		 *  --- prototype (non existing prototype: "incorrect")
		 *
		 * During:
		 *  - Should prompt for:
		 *  -- 'Select prototype'
		 *
		 * After:
		 *
		 */
		it('Should run `<command>` with predefined properties in mgnl.config.js, but incorrect value (4)', async () => {
			/* Setup */
			const lightModule = testEnv.lightModules.options.lm1.name; // my-lm
			const prototype = testEnv.customPrototypes.options._default.name; // _default

			const configBefore = parseConfig(testEnv.mgnlConfigPath);
			configBefore._export.lightModulesPath =
				testEnv.lightModules.relativePath;
			configBefore._export.lightModule = lightModule;
			addArgsToPlugin(configBefore, pluginClassName, {
				prototypeDir: testEnv.customPrototypes.relativePath,
			});
			addArgsToPlugin(configBefore, pluginClassName, {
				prototype: 'incorrect',
			});
			writeConfig(testEnv.mgnlConfigPath, configBefore);

			/* Command */
			const inputs = [
				// Choose prototype
				'1', // Move selection to: '1) _default'
				ENTER, // Confirm selection: '1) _default'
			];
			const output = await executeCommand(
				`${mgnlCommand} ${name}`,
				addPluginInputs(inputs, pluginInputs),
				testEnv.testDir,
			);

			/* Assertion */
			validateOutput(output);
			assertFiles(testEnv.lightModules.options.lm1.fullPath, {
				customPrototype: true,
			});
			assertConfig(
				testEnv.mgnlConfigPath,
				pluginClassName,
				{
					lightModulesPath: testEnv.lightModules.relativePath,
					lightModule,
				},
				{
					prototypeDir: testEnv.customPrototypes.relativePath,
					prototype,
				},
			);
		}, 15000);

		/*
		 * Action: Should run `<command>` with predefined properties in mgnl.config.js and options (1)
		 *
		 * Before:
		 *  - Predefined properties in mgnl.config.js:
		 *  -- global:
		 *  --- lightModulesPath (relative path)
		 *  - Passed args:
		 *  -- lightModule
		 *
		 * During:
		 *
		 * After:
		 *  - Should add properties to mgnl.config.js:
		 *  -- plugin:
		 *  --- lightModule
		 */
		it('Should run `<command>` with predefined properties in mgnl.config.js and options (1)', async () => {
			/* Setup */
			const lightModule = testEnv.lightModules.options.lm1.name; // my-lm

			const configBefore = parseConfig(testEnv.mgnlConfigPath);
			configBefore._export.lightModulesPath =
				testEnv.lightModules.relativePath;
			writeConfig(testEnv.mgnlConfigPath, configBefore);

			/* Command */
			const args = `-lm ${lightModule}`;
			const output = await executeCommand(
				`${mgnlCommand} ${name} ${args}`,
				addPluginInputs([], pluginInputs),
				testEnv.testDir,
			);

			/* Assertion */
			validateOutput(output);
			assertFiles(testEnv.lightModules.options.lm1.fullPath);
			assertConfig(
				testEnv.mgnlConfigPath,
				pluginClassName,
				{ lightModulesPath: testEnv.lightModules.relativePath },
				{ lightModule },
			);
		}, 15000);

		/*
		 * Action: Should run `<command>` with predefined properties in mgnl.config.js and options (2)
		 *
		 * Before:
		 *  - Predefined properties in mgnl.config.js:
		 *  -- global:
		 *  --- lightModulesPath (relative path)
		 *  --- lightModule
		 *  - Passed args:
		 *  -- prototypeDir (relative path)
		 *
		 * During:
		 *
		 * After:
		 *  - Should add properties to mgnl.config.js:
		 *  -- plugin:
		 *  --- lightModule
		 */
		it('Should run `<command>` with predefined properties in mgnl.config.js and options (2)', async () => {
			/* Setup */
			const lightModule = testEnv.lightModules.options.lm1.name; // my-lm

			const configBefore = parseConfig(testEnv.mgnlConfigPath);
			configBefore._export.lightModulesPath =
				testEnv.lightModules.relativePath;
			configBefore._export.lightModule = lightModule;
			writeConfig(testEnv.mgnlConfigPath, configBefore);

			/* Command */
			const args = `-pd ${testEnv.customPrototypes.relativePath}`;
			const output = await executeCommand(
				`${mgnlCommand} ${name} ${args}`,
				addPluginInputs([], pluginInputs),
				testEnv.testDir,
			);

			/* Assertion */
			validateOutput(output);
			assertFiles(testEnv.lightModules.options.lm1.fullPath, {
				customPrototype: true,
			});
			assertConfig(
				testEnv.mgnlConfigPath,
				pluginClassName,
				{
					lightModulesPath: testEnv.lightModules.relativePath,
					lightModule,
				},
				{ prototypeDir: testEnv.customPrototypes.relativePath },
			);
		}, 15000);

		/*
		 * Action: Should run `<command>` with predefined properties in mgnl.config.js and options (3)
		 *
		 * Before:
		 *  - Predefined properties in mgnl.config.js:
		 *  -- global:
		 *  --- lightModulesPath (relative path)
		 *  --- lightModule
		 *  - Passed args:
		 *  -- prototypeDir (full path)
		 *
		 * During:
		 *
		 * After:
		 *  - Should add properties to mgnl.config.js:
		 *  -- plugin:
		 *  --- lightModule
		 */
		it('Should run `<command>` with predefined properties in mgnl.config.js and options (3)', async () => {
			/* Setup */
			const lightModule = testEnv.lightModules.options.lm1.name; // my-lm

			const configBefore = parseConfig(testEnv.mgnlConfigPath);
			configBefore._export.lightModulesPath =
				testEnv.lightModules.relativePath;
			configBefore._export.lightModule = lightModule;
			writeConfig(testEnv.mgnlConfigPath, configBefore);

			/* Command */
			const args = `-pd ${testEnv.customPrototypes.fullPath}`;
			const output = await executeCommand(
				`${mgnlCommand} ${name} ${args}`,
				addPluginInputs([], pluginInputs),
				testEnv.testDir,
			);

			/* Assertion */
			validateOutput(output);
			assertFiles(testEnv.lightModules.options.lm1.fullPath, {
				customPrototype: true,
			});
			assertConfig(
				testEnv.mgnlConfigPath,
				pluginClassName,
				{
					lightModulesPath: testEnv.lightModules.relativePath,
					lightModule,
				},
				{ prototypeDir: testEnv.customPrototypes.relativePath },
			);
		}, 15000);

		/*
		 * Action: Should run `<command>` with predefined properties in mgnl.config.js and options (4)
		 *
		 * Before:
		 *  - Predefined properties in mgnl.config.js:
		 *  -- global:
		 *  --- lightModulesPath (relative path)
		 *  --- lightModule
		 *  -- plugin:
		 *  --- prototypeDir (relative path)
		 *  - Passed args:
		 *  -- prototype
		 *
		 * During:
		 *
		 * After:
		 *  - Should add properties to mgnl.config.js:
		 *  -- plugin:
		 *  --- prototype
		 */
		it('Should run `<command>` with predefined properties in mgnl.config.js and options (4)', async () => {
			/* Setup */
			const lightModule = testEnv.lightModules.options.lm1.name; // my-lm
			const prototype = testEnv.customPrototypes.options.prototype2.name; // prototype2

			const configBefore = parseConfig(testEnv.mgnlConfigPath);
			configBefore._export.lightModulesPath =
				testEnv.lightModules.relativePath;
			configBefore._export.lightModule = lightModule;
			addArgsToPlugin(configBefore, pluginClassName, {
				prototypeDir: testEnv.customPrototypes.relativePath,
			});
			writeConfig(testEnv.mgnlConfigPath, configBefore);

			/* Command */
			const args = `-p ${prototype}`;
			const output = await executeCommand(
				`${mgnlCommand} ${name} ${args}`,
				addPluginInputs([], pluginInputs),
				testEnv.testDir,
			);

			/* Assertion */
			validateOutput(output);
			assertFiles(testEnv.lightModules.options.lm1.fullPath, {
				customPrototype: true,
				prototype,
			});
			assertConfig(
				testEnv.mgnlConfigPath,
				pluginClassName,
				{
					lightModulesPath: testEnv.lightModules.relativePath,
					lightModule,
				},
				{
					prototypeDir: testEnv.customPrototypes.relativePath,
					prototype,
				},
			);
		}, 15000);

		/*
		 * Action: Should run `<command>` with predefined properties in mgnl.config.js and incorrect options (1)
		 *
		 * Before:
		 *  - Predefined properties in mgnl.config.js:
		 *  -- global:
		 *  --- lightModulesPath (relative path)
		 *  - Passed args:
		 *  -- lightModule (non existing lm: "incorrect")
		 *
		 * During:
		 *
		 * After:
		 *  - Should add properties to mgnl.config.js:
		 *  -- plugin:
		 *  --- lightModule
		 */
		it('Should run `<command>` with predefined properties in mgnl.config.js and incorrect options (1)', async () => {
			/* Setup */
			const lightModule = testEnv.lightModules.options.lm1.name; // my-lm

			const configBefore = parseConfig(testEnv.mgnlConfigPath);
			configBefore._export.lightModulesPath =
				testEnv.lightModules.relativePath;
			writeConfig(testEnv.mgnlConfigPath, configBefore);

			/* Command */
			const args = '-lm "incorrect"'; // non existing lm
			const inputs = [
				// Choose light module
				'1', // Move selection to: '1) my-lm'
				ENTER, // Confirm selection: '1) my-lm'
			];
			const output = await executeCommand(
				`${mgnlCommand} ${name} ${args}`,
				addPluginInputs(inputs, pluginInputs),
				testEnv.testDir,
			);

			/* Assertion */
			validateOutput(output);
			assertFiles(testEnv.lightModules.options.lm1.fullPath);
			assertConfig(
				testEnv.mgnlConfigPath,
				pluginClassName,
				{ lightModulesPath: testEnv.lightModules.relativePath },
				{ lightModule },
			);
		}, 15000);

		/*
		 * Action: Should run `<command>` with predefined properties in mgnl.config.js and incorrect options (2)
		 *
		 * Before:
		 *  - Predefined properties in mgnl.config.js:
		 *  -- global:
		 *  --- lightModulesPath (relative path)
		 *  --- lightModule
		 *  -- plugin:
		 *  --- prototypeDir (relative path)
		 *  - Passed args:
		 *  -- prototype  (non existing proto: "incorrect")
		 *
		 * During:
		 *
		 * After:
		 *  - Should add properties to mgnl.config.js:
		 *  -- plugin:
		 *  --- prototype
		 */
		it('Should run `<command>` with predefined properties in mgnl.config.js and incorrect options (2)', async () => {
			/* Setup */
			const lightModule = testEnv.lightModules.options.lm1.name; // my-lm
			const prototype = testEnv.customPrototypes.options._default.name; // _default

			const configBefore = parseConfig(testEnv.mgnlConfigPath);
			configBefore._export.lightModulesPath =
				testEnv.lightModules.relativePath;
			configBefore._export.lightModule = lightModule;
			addArgsToPlugin(configBefore, pluginClassName, {
				prototypeDir: testEnv.customPrototypes.relativePath,
			});
			writeConfig(testEnv.mgnlConfigPath, configBefore);

			/* Command */
			const args = '-p "incorrect"';
			const inputs = [
				// Choose prototype
				'1', // Move selection to: '1) _default'
				ENTER, // Confirm selection: '1) _default'
			];
			const output = await executeCommand(
				`${mgnlCommand} ${name} ${args}`,
				addPluginInputs(inputs, pluginInputs),
				testEnv.testDir,
			);

			/* Assertion */
			validateOutput(output);
			assertFiles(testEnv.lightModules.options.lm1.fullPath, {
				customPrototype: true,
			});
			assertConfig(
				testEnv.mgnlConfigPath,
				pluginClassName,
				{
					lightModulesPath: testEnv.lightModules.relativePath,
					lightModule,
				},
				{
					prototypeDir: testEnv.customPrototypes.relativePath,
					prototype,
				},
			);
		}, 15000);

		/*
		 * Action: Should run `<command>` with predefined properties in mgnl.config.js and options without values (1)
		 *
		 * Before:
		 *  - Predefined properties in mgnl.config.js:
		 *  -- global:
		 *  --- lightModulesPath (relative path)
		 *  - Passed args:
		 *  -- lightModule (without value)
		 *
		 * During:
		 *
		 * After:
		 *  - Should add properties to mgnl.config.js:
		 *  -- plugin:
		 *  --- lightModule
		 */
		it('Should run `<command>` with predefined properties in mgnl.config.js and options without values (1)', async () => {
			/* Setup */
			const lightModule = testEnv.lightModules.options.lm1.name; // my-lm

			const configBefore = parseConfig(testEnv.mgnlConfigPath);
			configBefore._export.lightModulesPath =
				testEnv.lightModules.relativePath;
			writeConfig(testEnv.mgnlConfigPath, configBefore);

			/* Command */
			const args = '-lm';
			const inputs = [
				// Choose light module
				'1', // Move selection to: '1) my-lm'
				ENTER, // Confirm selection: '1) my-lm'
			];
			const output = await executeCommand(
				`${mgnlCommand} ${name} ${args}`,
				addPluginInputs(inputs, pluginInputs),
				testEnv.testDir,
			);

			/* Assertion */
			validateOutput(output);
			assertFiles(testEnv.lightModules.options.lm1.fullPath);
			assertConfig(
				testEnv.mgnlConfigPath,
				pluginClassName,
				{ lightModulesPath: testEnv.lightModules.relativePath },
				{ lightModule },
			);
		}, 15000);

		/*
		 * Action: Should run `<command>` with predefined properties in mgnl.config.js and options without values (2)
		 *
		 * Before:
		 *  - Predefined properties in mgnl.config.js:
		 *  -- global:
		 *  --- lightModulesPath (relative path)
		 *  --- lightModule
		 *  -- plugin:
		 *  --- prototypeDir (relative path)
		 *  - Passed args:
		 *  -- prototype (without value)
		 *
		 * During:
		 *
		 * After:
		 *  - Should add properties to mgnl.config.js:
		 *  -- plugin:
		 *  --- prototype
		 */
		it('Should run `<command>` with predefined properties in mgnl.config.js and options without values (2)', async () => {
			/* Setup */
			const lightModule = testEnv.lightModules.options.lm1.name; // my-lm
			const prototype = testEnv.customPrototypes.options._default.name; // _default

			const configBefore = parseConfig(testEnv.mgnlConfigPath);
			configBefore._export.lightModulesPath =
				testEnv.lightModules.relativePath;
			configBefore._export.lightModule = lightModule;
			addArgsToPlugin(configBefore, pluginClassName, {
				prototypeDir: testEnv.customPrototypes.relativePath,
			});
			writeConfig(testEnv.mgnlConfigPath, configBefore);

			/* Command */
			const args = '-p';
			const inputs = [
				// Choose prototype
				'1', // Move selection to: '1) _default'
				ENTER, // Confirm selection: '1) _default'
			];
			const output = await executeCommand(
				`${mgnlCommand} ${name} ${args}`,
				addPluginInputs(inputs, pluginInputs),
				testEnv.testDir,
			);

			/* Assertion */
			validateOutput(output);
			assertFiles(testEnv.lightModules.options.lm1.fullPath, {
				customPrototype: true,
			});
			assertConfig(
				testEnv.mgnlConfigPath,
				pluginClassName,
				{
					lightModulesPath: testEnv.lightModules.relativePath,
					lightModule,
				},
				{
					prototypeDir: testEnv.customPrototypes.relativePath,
					prototype,
				},
			);
		}, 15000);
	});
}
