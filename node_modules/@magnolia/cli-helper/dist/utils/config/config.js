var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import * as prettier from 'prettier';
import path from 'path';
import fs from 'fs-extra';
import { pathToFileURL } from 'url';
import parser from '@babel/parser';
import t from '@babel/types';
import _generate from '@babel/generator';
import _traverse from '@babel/traverse';
const generate = _generate.default;
const traverse = _traverse.default;
import { i18nInstance } from '../i18n/i18n.js';
import prettierConfig from '../prettier-config/index.js';
let noMgnlConfigWarnShown = false;
export const getMgnlConfigPath = () => {
    const configPath = path.join(process.cwd(), 'mgnl.config.mjs');
    if (fs.existsSync(configPath))
        return configPath;
    return path.join(process.cwd(), 'mgnl.config.js');
};
export const getRelativePathToMGNLConfig = (p) => {
    const relativePath = path
        .normalize(path.relative(path.join(getMgnlConfigPath(), '..'), p))
        .replace(/\\/g, '/');
    return relativePath.startsWith('.') ? relativePath : './' + relativePath;
};
export const getMgnlConfig = (logger) => __awaiter(void 0, void 0, void 0, function* () {
    const mgnlConfigPath = getMgnlConfigPath();
    if (!fs.existsSync(mgnlConfigPath)) {
        if (!noMgnlConfigWarnShown) {
            logger === null || logger === void 0 ? void 0 : logger.warn(i18nInstance.t('warn-no-mgnl-config-file'));
            noMgnlConfigWarnShown = true;
        }
        return {};
    }
    try {
        return (yield import(pathToFileURL(mgnlConfigPath).href)).default;
    }
    catch (e) {
        logger === null || logger === void 0 ? void 0 : logger.warn(i18nInstance.t('warn-error-during-mgnl-config-js-import', {
            errorMsg: e.message,
        }));
        return {};
    }
});
export const readMgnlConfigFile = (logger) => {
    const localConfigPath = getMgnlConfigPath();
    if (!fs.existsSync(localConfigPath)) {
        if (!noMgnlConfigWarnShown) {
            logger === null || logger === void 0 ? void 0 : logger.warn(i18nInstance.t('warn-no-mgnl-config-file'));
            noMgnlConfigWarnShown = true;
        }
        return '';
    }
    return fs.readFileSync(localConfigPath, 'utf8');
};
export function modifyConfig(args, pluginName, logger) {
    return __awaiter(this, void 0, void 0, function* () {
        const trackedSharedProps = {
            updated: [],
            added: [],
        };
        const trackedPluginProps = {
            updated: [],
            added: [],
        };
        try {
            const content = readMgnlConfigFile(logger);
            if (!content)
                return;
            const ast = parser.parse(content, {
                sourceType: 'module',
                plugins: ['typescript'],
                attachComment: true,
            });
            let modificationsMade = false;
            // Traverse the AST to update shared and plugin properties
            traverse(ast, {
                ExportDefaultDeclaration({ node }) {
                    if (t.isObjectExpression(node.declaration)) {
                        // Update shared properties
                        if (args.sharedProps) {
                            modificationsMade = updateProperties(node.declaration.properties, args.sharedProps, trackedSharedProps);
                        }
                        // Update plugin properties
                        if (args.pluginProps) {
                            const pluginsArray = findPluginsArray(node.declaration.properties);
                            if (pluginsArray) {
                                pluginsArray.elements.forEach((pluginNode) => {
                                    if (isMatchingPlugin(pluginNode, pluginName)) {
                                        let pluginOptions = pluginNode.arguments[0];
                                        // If pluginOptions is undefined, create an empty ObjectExpression
                                        if (!pluginOptions ||
                                            !t.isObjectExpression(pluginOptions)) {
                                            pluginOptions = t.objectExpression([]);
                                            pluginNode.arguments[0] = pluginOptions; // Assign the new ObjectExpression
                                        }
                                        modificationsMade =
                                            updateProperties(pluginOptions.properties, args.pluginProps, trackedPluginProps) || modificationsMade;
                                    }
                                });
                            }
                        }
                    }
                },
            });
            if (modificationsMade) {
                const output = generate(ast, {}, content);
                const formatted = yield prettier.format(output.code.trim(), Object.assign(Object.assign({}, prettierConfig), { parser: 'babel' }));
                fs.writeFileSync(getMgnlConfigPath(), formatted, 'utf-8');
                logChangedProperties(trackedSharedProps, 'global', logger);
                logChangedProperties(trackedPluginProps, 'plugins', logger);
            }
        }
        catch (_a) {
            logger === null || logger === void 0 ? void 0 : logger.error(i18nInstance.t('error-during-mgnl-config-modification'));
            logger === null || logger === void 0 ? void 0 : logger.error(i18nInstance.t('error-ensure-mgnl-not-corrupted'));
        }
    });
}
// Update properties and track changes
function updateProperties(objectProperties, newProps, trackedProps) {
    let modified = false;
    Object.entries(newProps).forEach(([key, value]) => {
        let propExists = false;
        objectProperties.forEach((property) => {
            if (isMatchingProperty(property, key)) {
                propExists = true;
                if (!isValueEqual(property.value, value)) {
                    property.value = valueToAstNode(value);
                    modified = true;
                    trackedProps.updated.push(key);
                }
            }
        });
        if (!propExists) {
            objectProperties.unshift(createObjectProperty(key, value));
            modified = true;
            trackedProps.added.push(key);
        }
    });
    return modified;
}
// Log changed properties
function logChangedProperties(props, type, logger) {
    props === null || props === void 0 ? void 0 : props.updated.forEach((property) => {
        logger === null || logger === void 0 ? void 0 : logger.info(i18nInstance.t('info-updated-property-in-mgnl-config', {
            type,
            property,
        }));
    });
    props === null || props === void 0 ? void 0 : props.added.forEach((property) => {
        logger === null || logger === void 0 ? void 0 : logger.info(i18nInstance.t('info-added-property-to-mgnl-config', {
            type,
            property,
        }));
    });
}
// Create an object property node
function createObjectProperty(key, value) {
    return t.objectProperty(t.isValidIdentifier(key) ? t.identifier(key) : t.stringLiteral(key), valueToAstNode(value));
}
// Find the plugins array property
function findPluginsArray(properties) {
    const { value } = properties.find((property) => t.isObjectProperty(property) &&
        t.isIdentifier(property.key) &&
        property.key.name === 'plugins' &&
        t.isArrayExpression(property.value));
    return value;
}
// Check if an object property matches the key
function isMatchingProperty(property, key) {
    return (t.isObjectProperty(property) &&
        ((t.isIdentifier(property.key) && property.key.name === key) ||
            (t.isStringLiteral(property.key) && property.key.value === key)));
}
// Check if a plugin node matches the given plugin name
function isMatchingPlugin(pluginNode, pluginName) {
    return (t.isNewExpression(pluginNode) &&
        t.isIdentifier(pluginNode.callee) &&
        pluginNode.callee.name === pluginName);
}
// Compares a Babel AST node's value to a given JavaScript value for equality
const isValueEqual = (nodeValue, newValue) => {
    if (t.isStringLiteral(nodeValue) && typeof newValue === 'string') {
        return nodeValue.value === newValue;
    }
    else if (t.isNumericLiteral(nodeValue) && typeof newValue === 'number') {
        return nodeValue.value === newValue;
    }
    else if (t.isBooleanLiteral(nodeValue) && typeof newValue === 'boolean') {
        return nodeValue.value === newValue;
    }
    else if (t.isNullLiteral(nodeValue) && newValue === null) {
        return true;
    }
    else if (t.isArrayExpression(nodeValue) && Array.isArray(newValue)) {
        return nodeValue.elements.every((element, index) => isValueEqual(element, newValue[index]));
    }
    else if (t.isObjectExpression(nodeValue) &&
        typeof newValue === 'object' &&
        !Array.isArray(newValue)) {
        return nodeValue.properties.every((prop) => {
            const key = t.isIdentifier(prop.key)
                ? prop.key.name
                : prop.key.value;
            return isValueEqual(prop.value, newValue[key]);
        });
    }
    return false;
};
// Converts a JavaScript value to a Babel AST node
const valueToAstNode = (value) => {
    if (typeof value === 'string') {
        return t.stringLiteral(value);
    }
    else if (typeof value === 'boolean') {
        return t.booleanLiteral(value);
    }
    else if (typeof value === 'number') {
        return t.numericLiteral(value);
    }
    else if (Array.isArray(value)) {
        return t.arrayExpression(value.map((item) => valueToAstNode(item)));
    }
    else if (typeof value === 'object') {
        return t.objectExpression(Object.entries(value).map(([key, val]) => t.objectProperty(t.isValidIdentifier(key)
            ? t.identifier(key)
            : t.stringLiteral(key), valueToAstNode(val))));
    }
    else {
        throw new TypeError('Unsupported type');
    }
};
