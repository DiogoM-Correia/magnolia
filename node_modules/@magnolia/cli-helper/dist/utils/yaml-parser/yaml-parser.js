import YAML from 'yaml';
import path from 'path';
import fs from 'fs-extra';
import { i18nInstance } from '../i18n/i18n.js';
function parseYamlWithDirectives(filePath, lightModulePath, logger) {
    try {
        let content = fs.readFileSync(filePath, 'utf8');
        content = removeContentTypeMarkers(content);
        let previous;
        do {
            previous = content;
            content = resolveIncludes(content, lightModulePath, logger);
            content = resolveInherits(content, filePath, lightModulePath, logger);
        } while (content !== previous);
        const doc = YAML.parseDocument(content);
        if (doc.errors && doc.errors.length) {
            const nonDuplicateErrors = doc.errors.filter((e) => e.code !== 'DUPLICATE_KEY');
            if (nonDuplicateErrors.length > 0) {
                logger.warn(i18nInstance.t('warn-cannot-parse-yaml', {
                    path: filePath,
                }));
                return null;
            }
        }
        return doc.toJSON();
    }
    catch (_a) {
        logger.warn(i18nInstance.t('warn-cannot-parse-yaml', { path: filePath }));
        return null;
    }
}
function removeContentTypeMarkers(text) {
    return text
        .split(/\r?\n/)
        .filter((line) => !line.trim().toLowerCase().startsWith('!content-type:'))
        .join('\n');
}
function resolveIncludes(content, lightModulePath, logger) {
    const includePattern = /!include:(\S+)/g;
    return content.replace(includePattern, (match, includePath, offset, fullString) => {
        const lineStart = fullString.lastIndexOf('\n', offset) + 1;
        const lineEnd = fullString.indexOf('\n', offset);
        const line = fullString.substring(lineStart, lineEnd === -1 ? fullString.length : lineEnd);
        const indentMatch = line.match(/^(\s*)/);
        const indentation = indentMatch ? indentMatch[1] : '';
        const resolvedPath = parser.resolveIncludePath(includePath, lightModulePath);
        if (!fs.existsSync(resolvedPath)) {
            logger.warn(i18nInstance.t('warn-included-file-not-found', {
                path: resolvedPath,
            }));
            return '';
        }
        const parsed = parseYamlWithDirectives(resolvedPath, lightModulePath, logger);
        if (parsed == null) {
            logger.warn(i18nInstance.t('warn-ignoring-included-file', {
                path: resolvedPath,
            }));
            return '';
        }
        const dumped = YAML.stringify(parsed);
        const lines = dumped.split(/\r?\n/).filter((l) => l.length > 0);
        if (line.trim() === match) {
            // — Inline include — no extra indent on first line
            return lines
                .map((l, i) => (i === 0 ? l : indentation + l))
                .join('\n');
        }
        else {
            // — Value include — nest two more spaces under the field
            const newIndent = indentation + '  ';
            return '\n' + lines.map((l) => newIndent + l).join('\n');
        }
    });
}
function resolveInherits(content, currentFile, lightModulePath, logger) {
    if (!content.includes('!inherit:')) {
        return content.replace(/__OVERRIDE__: true\n[ \t]*/g, '');
    }
    const preprocessed = preprocessOverrideMarkers(content);
    const inheritRegex = /^!inherit:(\S+)$/gm;
    const matches = Array.from(preprocessed.matchAll(inheritRegex));
    let baseObj = {};
    for (const match of matches) {
        const relPath = match[1];
        const inheritedFile = parser.resolveInheritPath(relPath, currentFile, lightModulePath);
        if (!inheritedFile || !fs.existsSync(inheritedFile)) {
            logger.warn(i18nInstance.t('warn-inherit-file-not-found', {
                path: relPath,
            }));
            continue;
        }
        try {
            const inheritedObj = parseYamlWithDirectives(inheritedFile, lightModulePath, logger) || {};
            baseObj = deepMerge(baseObj, inheritedObj);
        }
        catch (_a) {
            logger.warn(i18nInstance.t('warn-ignoring-inherit-file', { path: relPath }));
        }
    }
    const overrideContent = preprocessed.replace(inheritRegex, '');
    const overrideObj = parseRawYaml(overrideContent);
    const merged = deepMerge(baseObj, overrideObj);
    return YAML.stringify(merged);
}
function parseRawYaml(text) {
    try {
        const doc = YAML.parseDocument(text);
        return doc.toJSON() || {};
    }
    catch (_a) {
        return {};
    }
}
function preprocessOverrideMarkers(text) {
    return text.replace(/:\s*!override\s*\n([ \t]+)/g, (m, indent) => `:\n${indent}__OVERRIDE__: true\n${indent}`);
}
function resolveInheritPath(relPath, currentFile, lightModulePath) {
    const lightModulesDir = path.resolve(lightModulePath, '..');
    const type = path.relative(lightModulePath, currentFile).split(path.sep)[0];
    if (['dialogs', 'templates'].includes(type)) {
        const [module, name] = relPath.split(':');
        return path.join(lightModulesDir, module, type, `${name}.yaml`);
    }
    return path.join(lightModulePath, type, `${relPath}.yaml`);
}
function deepMerge(base, override) {
    if (override && override.__OVERRIDE__ === true) {
        const clone = Object.assign({}, override);
        delete clone.__OVERRIDE__;
        return clone;
    }
    if (isObject(base) && isObject(override)) {
        for (const key of Object.keys(override)) {
            base[key] = deepMerge(base[key], override[key]);
        }
        return base;
    }
    return override !== undefined ? override : base;
}
function resolveIncludePath(relPath, lightModulePath) {
    return path.join(lightModulePath, '..', relPath);
}
function isObject(val) {
    return val !== null && typeof val === 'object' && !Array.isArray(val);
}
export const parser = {
    parseYamlWithDirectives,
    resolveInheritPath,
    resolveIncludePath,
};
