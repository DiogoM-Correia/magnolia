var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import path from 'path';
import fs from 'fs-extra';
import inquirer from 'inquirer';
import { CreateError, getAbsolutePath, prependNumbersToChoices, } from '../general-utils/general-utils.js';
import { getMgnlConfig, getRelativePathToMGNLConfig, readMgnlConfigFile, } from '../config/config.js';
import { promptForDirOrFile } from '../prompt/prompt.js';
import { i18nInstance } from '../i18n/i18n.js';
export function resolveLightModulesPath(options_1, config_1, logger_1) {
    return __awaiter(this, arguments, void 0, function* (options, config, logger, showMsg = false) {
        let newLightModulesPath, lightModulesPath, source;
        if (options === null || options === void 0 ? void 0 : options.lightModulesPath) {
            lightModulesPath = options === null || options === void 0 ? void 0 : options.lightModulesPath;
            source = 'option';
        }
        else if (config === null || config === void 0 ? void 0 : config.lightModulesPath) {
            lightModulesPath = config === null || config === void 0 ? void 0 : config.lightModulesPath;
            source = 'global';
        }
        if (typeof lightModulesPath === 'string') {
            if (source === 'global') {
                lightModulesPath = path.resolve(process.cwd(), lightModulesPath);
            }
            else {
                lightModulesPath = path.resolve(process.env.INIT_CWD || process.cwd(), lightModulesPath);
            }
            if (!fs.existsSync(lightModulesPath)) {
                logger === null || logger === void 0 ? void 0 : logger.warn(i18nInstance.t(`warn-provided-lm-path-not-exists-${source}`, {
                    lightModulesPath: path.resolve(process.cwd(), lightModulesPath),
                }));
                lightModulesPath = yield promptForDirOrFile({
                    logger,
                    message: i18nInstance.t('info-select-light-modules'),
                });
                if (source !== 'option' || !(config === null || config === void 0 ? void 0 : config.lightModulesPath)) {
                    newLightModulesPath = getRelativePathToMGNLConfig(lightModulesPath.replace(/\\+/g, '/'));
                }
            }
            else {
                if (showMsg) {
                    if (source === 'global') {
                        logger === null || logger === void 0 ? void 0 : logger.info(i18nInstance.t('info-using-config-lmp', {
                            path: lightModulesPath,
                        }));
                    }
                    else {
                        logger === null || logger === void 0 ? void 0 : logger.info(i18nInstance.t('info-using-option-lmp', {
                            path: lightModulesPath,
                        }));
                    }
                }
                if (source === 'option' && !(config === null || config === void 0 ? void 0 : config.lightModulesPath)) {
                    newLightModulesPath = getRelativePathToMGNLConfig(lightModulesPath.replace(/\\+/g, '/'));
                }
            }
        }
        else {
            lightModulesPath = yield promptForDirOrFile({
                logger,
                message: i18nInstance.t('info-select-light-modules'),
            });
            if (!(config === null || config === void 0 ? void 0 : config.lightModulesPath)) {
                newLightModulesPath = getRelativePathToMGNLConfig(lightModulesPath.replace(/\\+/g, '/'));
            }
        }
        return {
            lightModulesPath: path.resolve(process.cwd(), lightModulesPath),
            newLightModulesPath,
        };
    });
}
export function resolveLightModule(options, pluginArgs, config, lightModulesPath, logger) {
    return __awaiter(this, void 0, void 0, function* () {
        var _a;
        const availableLightModules = fs
            .readdirSync(lightModulesPath, { withFileTypes: true })
            .filter((dirent) => dirent.isDirectory())
            .map((dirent) => dirent.name);
        if (availableLightModules.length === 0) {
            const noLmAvailableMsg = i18nInstance.t('error-no-lm-available', {
                lightModulesPath,
            });
            let createLmMsg = i18nInstance.t('error-lm-plugin-not-installed');
            if ((_a = readMgnlConfigFile(logger)) === null || _a === void 0 ? void 0 : _a.match(/import\s+CreateLightModulePlugin/)) {
                createLmMsg = i18nInstance.t('error-lm-plugin-installed');
            }
            throw new CreateError(`${noLmAvailableMsg}\n${createLmMsg}`);
        }
        let lm;
        let lightModuleMsg;
        if (typeof options.lightModule !== 'boolean') {
            if (options.lightModule) {
                lm = options.lightModule;
                lightModuleMsg = 'info-using-option-lm';
            }
            else if (pluginArgs.lightModule) {
                lm = pluginArgs.lightModule;
                lightModuleMsg = 'info-using-plugin-lm';
            }
            else if (config.lightModule) {
                lm = config.lightModule;
                lightModuleMsg = 'info-using-global-lm';
            }
        }
        const lightModule = yield checkLmAvailability(lm, lightModulesPath, availableLightModules, logger);
        const newLightModule = lightModule !== lm || (options === null || options === void 0 ? void 0 : options.lightModule) ? lightModule : undefined;
        return { lightModule, newLightModule, lightModuleMsg };
    });
}
export function prepareLightModule(options, pluginArgs, logger) {
    return __awaiter(this, void 0, void 0, function* () {
        const config = yield getMgnlConfig(logger);
        const { lightModulesPath, newLightModulesPath } = yield resolveLightModulesPath(options, config, logger);
        const { lightModule, newLightModule, lightModuleMsg } = yield resolveLightModule(options, pluginArgs, config, lightModulesPath, logger);
        const lightModulePath = getAbsolutePath(path.join(lightModulesPath, lightModule));
        if (lightModuleMsg) {
            logger === null || logger === void 0 ? void 0 : logger.info(i18nInstance.t(lightModuleMsg, { path: lightModulePath }));
        }
        return {
            lightModulePath,
            newLightModulesPath,
            newLightModule,
        };
    });
}
function checkLmAvailability(lightModule, lightModulesPath, availableLightModules, logger) {
    return __awaiter(this, void 0, void 0, function* () {
        let prompt = true;
        if (lightModule !== undefined) {
            prompt = !availableLightModules.includes(lightModule);
            if (prompt) {
                logger === null || logger === void 0 ? void 0 : logger.warn(i18nInstance.t('warn-lm-not-in-lmp', {
                    lightModule: lightModule,
                    lightModulesPath: lightModulesPath,
                }));
            }
        }
        if (prompt || lightModule === undefined) {
            const choicesWithNumbers = prependNumbersToChoices(availableLightModules);
            const { chosenLightModule } = yield inquirer.prompt([
                {
                    type: 'list',
                    name: 'chosenLightModule',
                    message: i18nInstance.t('inquirer-prompt-select-lm'),
                    choices: choicesWithNumbers,
                },
            ]);
            lightModule = chosenLightModule;
        }
        return lightModule;
    });
}
