var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import fs from 'fs-extra';
import path from 'path';
import inquirer from 'inquirer';
import { i18nInstance } from '../i18n/i18n.js';
import { prependNumbersToChoices } from '../general-utils/general-utils.js';
export function promptForDirOrFile() {
    return __awaiter(this, arguments, void 0, function* (options = {}) {
        const { type = 'dir', logger, createNew = false, fileContent = '', message, } = options;
        let { currentPath = process.cwd() } = options;
        // Get list of directories or directories and files based on the 'type' parameter
        const entries = fs
            .readdirSync(currentPath, { withFileTypes: true })
            .filter((dirent) => {
            if (type === 'dir') {
                return dirent.isDirectory();
            }
            else {
                return dirent.isDirectory() || dirent.isFile();
            }
        })
            .map((dirent) => ({
            name: dirent.name,
            value: path.join(currentPath, dirent.name),
        }));
        // Prepare choices for inquirer prompt
        const choices = [
            ...(createNew
                ? [
                    new inquirer.Separator(),
                    {
                        name: i18nInstance.t('inquirer-choice-create-new', {
                            type: type === 'dir' ? 'directory' : 'file',
                        }),
                        value: 'CREATE_NEW',
                    },
                ]
                : []),
            ...(type === 'dir'
                ? [
                    new inquirer.Separator(),
                    {
                        name: i18nInstance.t('inquirer-choice-use-this-dir'),
                        value: 'USE_THIS_DIR',
                    },
                ]
                : []),
            new inquirer.Separator(),
            { name: '..', value: path.join(currentPath, '..') },
            new inquirer.Separator(),
            ...entries,
        ];
        // Prompt the user to select a directory or file
        if (message) {
            logger === null || logger === void 0 ? void 0 : logger.info(message);
        }
        const answer = yield inquirer.prompt([
            {
                type: 'list',
                name: 'selectedPath',
                message: i18nInstance.t('inquirer-prompt-selected-dir', {
                    currentPath,
                }),
                choices: choices,
            },
        ]);
        // Check the user's selection and return the appropriate path
        if (answer.selectedPath === 'USE_THIS_DIR') {
            // If the user selects the current directory, return it as the final path
            return currentPath;
        }
        else if (answer.selectedPath === 'CREATE_NEW') {
            // If the user selects to create a new file or directory
            const { entityName } = yield inquirer.prompt({
                type: 'input',
                name: 'entityName',
                message: i18nInstance.t(`inquirer-prompt-enter-${type}`),
            });
            const newEntity = path.join(currentPath, entityName);
            if (!fs.existsSync(newEntity)) {
                if (type === 'dir') {
                    fs.ensureDirSync(newEntity);
                }
                else {
                    fs.writeFileSync(newEntity, fileContent !== null && fileContent !== void 0 ? fileContent : '');
                }
                return newEntity;
            }
            else {
                // If the new entity already exists, log a warning and prompt the user again
                logger === null || logger === void 0 ? void 0 : logger.warn(i18nInstance.t(`warn-${type}-with-name-exists`, {
                    name: newEntity,
                }));
                return yield promptForDirOrFile({
                    currentPath,
                    type,
                    logger,
                    createNew,
                    fileContent,
                });
            }
        }
        else {
            currentPath = answer.selectedPath;
            const isFile = fs.statSync(currentPath).isFile();
            if (isFile) {
                return currentPath;
            }
            else {
                // If it's a directory, recursively call the function to prompt again inside the selected directory
                currentPath = yield promptForDirOrFile({
                    currentPath,
                    type,
                    logger,
                    createNew,
                    fileContent,
                });
            }
        }
        return currentPath;
    });
}
export function promptForPrototype(availablePrototypes) {
    return __awaiter(this, void 0, void 0, function* () {
        const choicesWithNumbers = prependNumbersToChoices(availablePrototypes);
        const { name } = yield inquirer.prompt([
            {
                type: 'list',
                name: 'name',
                default: '_default',
                choices: choicesWithNumbers,
                message: i18nInstance.t('inquirer-prompt-select-prototype'),
            },
        ]);
        return name;
    });
}
