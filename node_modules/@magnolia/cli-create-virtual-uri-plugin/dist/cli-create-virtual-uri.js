var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import path from 'path';
import { fileURLToPath } from 'url';
import { Option } from 'commander';
import { createRequire } from 'module';
import { PluginTemplate } from '@magnolia/cli-plugin-template';
import { getAvailablePrototypes, initI18n, modifyConfig, getModuleName, getRelativePathToMGNLConfig, stripLastSep, findPrototypesPath, prepareLightModule, checkFlagsValue, validateName, validateAndResolvePrototype, CreateError, } from '@magnolia/cli-helper';
import fs from 'fs-extra';
import Handlebars from 'handlebars';
const requireFn = createRequire(import.meta.url);
const pkg = requireFn('./package.json');
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const cliPrototypesPath = path.resolve(__dirname, './resources/config/mgnl-cli-prototypes/virtual-uri');
export let logger;
export let i18nInstance = {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    t(key, options) {
        return key;
    },
};
export default class CreateVirtualUriPlugin extends PluginTemplate {
    constructor(args) {
        super();
        this.pluginName = this.constructor.name;
        this.name = 'create-virtual-uri';
        this.version = pkg.version;
        this.usage = '<name> [options]' +
            '\nParameter: <name> The name of the virtual URI mapping file. Avoid slash characters.';
        this.configUpdates = {
            sharedProps: {},
            pluginProps: {},
        };
        i18nInstance = initI18n(this.name, 'translation', path.join(__dirname, 'lib/locales'));
        this.description = i18nInstance.t('description');
        const prototypesPath = findPrototypesPath(args === null || args === void 0 ? void 0 : args.prototypeDir, cliPrototypesPath);
        const prototypes = getAvailablePrototypes(prototypesPath);
        const cmdOptionPrototype = prototypes
            ? 'option-prototype-description.withPrototypes'
            : 'option-prototype-description.noPrototypes';
        this.options = [
            new Option('-f --from <uri>', i18nInstance.t('option-fromUri-description')).default(''),
            new Option('-t --to <prefix:uri>', i18nInstance.t('option-toUri-description')).default(''),
            new Option('-lm --light-module [name]', i18nInstance.t('option-lightModule-description')),
            new Option('-pd --prototype-dir <path>', i18nInstance.t('option-prototypeDir-description')),
            new Option('-p --prototype [name]', i18nInstance.t(cmdOptionPrototype, {
                prototypes,
                path: prototypesPath,
            })),
        ];
        this.args = args || {};
    }
    init(winstonLogger) {
        return __awaiter(this, void 0, void 0, function* () {
            logger = winstonLogger;
        });
    }
    start(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const params = yield this.validateAndResolveArgs(options);
            yield this.createVirtualUri(params);
            yield modifyConfig(this.configUpdates, this.pluginName, logger);
        });
    }
    stop() {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    validateAndResolveArgs(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const newVirtualUri = validateName('virtual uri');
            checkFlagsValue(this.options, options);
            const toUri = options.to;
            if (toUri !== '') {
                // we support 3 actions -> redirect, permanent and forward
                if (!(toUri.startsWith('redirect:') ||
                    toUri.startsWith('permanent:') ||
                    toUri.startsWith('forward:'))) {
                    throw new CreateError(i18nInstance.t('error-invalid-action'));
                }
            }
            const { lightModulePath, newLightModulesPath, newLightModule } = yield prepareLightModule(options, this.args, logger);
            if (newLightModulesPath) {
                this.configUpdates.sharedProps.lightModulesPath =
                    getRelativePathToMGNLConfig(newLightModulesPath);
            }
            if (newLightModule) {
                this.configUpdates.pluginProps.lightModule = newLightModule;
            }
            const { prototype, prototypeDir, pluginUpdates } = yield validateAndResolvePrototype(options, this.args, cliPrototypesPath, logger);
            this.configUpdates.pluginProps = Object.assign(Object.assign({}, this.configUpdates.pluginProps), pluginUpdates);
            return {
                name: newVirtualUri,
                prototypeName: prototype,
                prototypeDir: prototypeDir,
                moduleName: getModuleName(lightModulePath),
                lightModulePath: stripLastSep(lightModulePath),
                uriVariables: {
                    fromUri: options.from,
                    toUri: options.to,
                },
            };
        });
    }
    createVirtualUri(vars) {
        return __awaiter(this, void 0, void 0, function* () {
            const { prototypeDir, prototypeName, name, lightModulePath, uriVariables, } = vars;
            const source = path.join(prototypeDir, prototypeName, 'virtualUriMappings/{{name}}.yaml');
            const target = path.join(lightModulePath, `virtualUriMappings/${name}.yaml`);
            if (!fs.existsSync(source)) {
                throw new CreateError(i18nInstance.t('error-prototype-file-does-not-exist', {
                    fileName: path.basename(source),
                    path: source,
                }));
            }
            if (fs.existsSync(target)) {
                logger === null || logger === void 0 ? void 0 : logger.error(i18nInstance.t('error-virtual-uri-already-exists', {
                    name,
                    path: target,
                }));
                throw new CreateError(i18nInstance.t('error-choose-different-name'));
            }
            try {
                const file = fs.readFileSync(source, 'utf8');
                const doc = Handlebars.compile(file)(Object.assign({}, uriVariables));
                fs.outputFileSync(path.join(target), doc, 'utf8');
                logger === null || logger === void 0 ? void 0 : logger.info(i18nInstance.t('info-file-created', {
                    file: name,
                    path: target,
                }));
            }
            catch (error) {
                throw new CreateError(i18nInstance.t('error-failed-to-create-file', {
                    errorMessage: error.message,
                }));
            }
        });
    }
}
