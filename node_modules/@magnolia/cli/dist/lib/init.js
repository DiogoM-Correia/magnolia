var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { PluginTemplate } from '@magnolia/cli-plugin-template';
import path from 'path';
import { initI18n } from '@magnolia/cli-helper/i18n';
import { fileURLToPath } from 'url';
import { getMgnlConfigPath, CreateError } from '@magnolia/cli-helper';
import { pathToFileURL } from 'url';
import { setLogger as setConfigLogger, handleMGNLConfigFile, } from './config-helper.js';
import fs from 'fs-extra';
import { execa } from 'execa';
import { determinePackageManager, hasCliInstalled, installCLI, installPackage, } from './helper.js';
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const i18nNamespace = 'init';
export let logger;
export let i18nInstance = {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    t(key, options) {
        return key;
    },
};
export default class Init extends PluginTemplate {
    constructor(args) {
        super();
        this.name = 'init';
        this.usage = '[options]';
        this.pjPath = path.join(process.cwd(), 'package.json');
        this.configurationSummary = [];
        this.deferredErrors = [];
        i18nInstance = initI18n(this.name, i18nNamespace, path.join(__dirname, 'locales'));
        this.description = i18nInstance.t('init--description');
        this.version = args.version;
        this.configPath = '';
    }
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                this.configPath = getMgnlConfigPath();
                logger === null || logger === void 0 ? void 0 : logger.info(i18nInstance.t('init--info-starting'));
                if (yield this.isProjectAlreadyInitialized()) {
                    logger === null || logger === void 0 ? void 0 : logger.info(i18nInstance.t('init--info-already-initialized'));
                    return;
                }
                this.projectType = yield this.detectProjectType();
                yield this.initProject();
                this.showSummary();
            }
            catch (e) {
                if (e instanceof CreateError) {
                    logger === null || logger === void 0 ? void 0 : logger.error(e.message);
                }
                else if (e instanceof Error) {
                    logger === null || logger === void 0 ? void 0 : logger.error(i18nInstance.t('init--error-non-mgnl-error', {
                        errorMsg: e.message,
                    }));
                }
                else {
                    throw e;
                }
            }
        });
    }
    stop() {
        return Promise.resolve(undefined);
    }
    init(winstonLogger) {
        logger = winstonLogger;
        setConfigLogger(winstonLogger);
    }
    isProjectAlreadyInitialized() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            const packageJsonExists = fs.existsSync(this.pjPath);
            const configExists = fs.existsSync(this.configPath);
            let hasCliDependency = false;
            let hasCliScript = false;
            let hasModuleTypeOrMjsConfig = false;
            if (packageJsonExists) {
                try {
                    const packageJson = JSON.parse(fs.readFileSync(this.pjPath, 'utf8'));
                    hasCliDependency = hasCliInstalled(packageJson);
                    hasCliScript = ((_a = packageJson === null || packageJson === void 0 ? void 0 : packageJson.scripts) === null || _a === void 0 ? void 0 : _a.mgnl) !== undefined;
                    hasModuleTypeOrMjsConfig =
                        (packageJson === null || packageJson === void 0 ? void 0 : packageJson.type) === 'module' ||
                            fs.existsSync(path.join(process.cwd(), 'mgnl.config.mjs'));
                }
                catch (e) {
                    logger === null || logger === void 0 ? void 0 : logger.error(i18nInstance.t('init--error-invalid-package-json', {
                        errorMsg: e.message,
                    }));
                    throw new CreateError(i18nInstance.t('init--error-cannot-proceed-invalid-package-json'));
                }
            }
            return (packageJsonExists &&
                hasCliDependency &&
                hasCliScript &&
                hasModuleTypeOrMjsConfig &&
                configExists);
        });
    }
    detectProjectType() {
        return __awaiter(this, void 0, void 0, function* () {
            const isHAProject = yield this.isHeadlessAcceleratorProject();
            const hasApacheTomcat = yield this.hasApacheTomcatStructure();
            let projectTypeName = 'Generic Node.js Project';
            if (isHAProject && hasApacheTomcat) {
                projectTypeName = 'Full Magnolia Project (Tomcat + Frontend)';
            }
            else if (isHAProject) {
                projectTypeName = 'Headless Accelerator CLI Project';
            }
            else if (hasApacheTomcat) {
                projectTypeName = 'Magnolia Backend Project (Tomcat)';
            }
            return {
                name: projectTypeName,
                hasApacheTomcat,
                isHAProject,
            };
        });
    }
    hasApacheTomcatStructure() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                // Check for Magnolia webapps by looking for NOTICE.txt files
                const { glob } = yield import('glob');
                const noticeFiles = yield glob('**/webapps/*/NOTICE.txt', {
                    cwd: process.cwd(),
                    dot: true,
                });
                for (const noticeFile of noticeFiles) {
                    try {
                        const content = fs.readFileSync(path.join(process.cwd(), noticeFile), 'utf8');
                        if (content.trim().startsWith('Magnolia')) {
                            return true;
                        }
                    }
                    catch (error) {
                        logger === null || logger === void 0 ? void 0 : logger.warn(i18nInstance.t('init--warn-failed-read-notice', {
                            error,
                        }));
                    }
                }
            }
            catch (error) {
                logger === null || logger === void 0 ? void 0 : logger.warn(i18nInstance.t('init--warn-failed-search-webapps', {
                    error,
                }));
            }
            return false;
        });
    }
    isHeadlessAcceleratorProject() {
        return __awaiter(this, void 0, void 0, function* () {
            const currentDir = process.cwd();
            const haIndicators = ['.mgnljumpstart/'];
            for (const indicator of haIndicators) {
                if (fs.existsSync(path.join(currentDir, indicator))) {
                    return true;
                }
            }
            return false;
        });
    }
    initProject() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.projectType) {
                throw new CreateError(i18nInstance.t('init--error-project-type-not-detected'));
            }
            yield this.ensurePackageJsonExists();
            yield this.ensureMagnoliaCliInstalled();
            yield this.ensureMgnlScriptExists();
            yield this.ensureConfigFileIsValid();
            if (this.projectType.isHAProject) {
                yield this.handleHAProjectSetup();
            }
        });
    }
    ensurePackageJsonExists() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!fs.existsSync(this.pjPath)) {
                logger === null || logger === void 0 ? void 0 : logger.info(i18nInstance.t('init--info-creating-package-json'));
                const isEsModule = fs.existsSync(this.configPath)
                    ? this.configPath.endsWith('.mjs')
                        ? false
                        : true
                    : true;
                try {
                    const projectName = path.basename(process.cwd());
                    const packageJson = {
                        name: projectName,
                        version: '1.0.0',
                        dependencies: {},
                        devDependencies: {},
                    };
                    if (isEsModule) {
                        packageJson.type = 'module';
                    }
                    fs.writeFileSync(this.pjPath, JSON.stringify(packageJson, null, '\t'), 'utf8');
                    this.configurationSummary.push(i18nInstance.t('init--summary-package-json-created'));
                }
                catch (e) {
                    throw new CreateError(i18nInstance.t('init--error-creating-package-json', {
                        errorMsg: e.message,
                    }));
                }
            }
        });
    }
    ensureMagnoliaCliInstalled() {
        return __awaiter(this, void 0, void 0, function* () {
            const packageJson = JSON.parse(fs.readFileSync(this.pjPath, 'utf8'));
            const cliInstalled = hasCliInstalled(packageJson);
            if (!cliInstalled) {
                logger === null || logger === void 0 ? void 0 : logger.info(i18nInstance.t('init--info-installing-magnolia-cli'));
                const success = yield installCLI();
                if (success) {
                    this.configurationSummary.push(i18nInstance.t('init--summary-magnolia-cli-installed'));
                }
                else {
                    throw new CreateError(i18nInstance.t('init--error-installing-magnolia-cli'));
                }
            }
        });
    }
    ensureMgnlScriptExists() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            const packageJson = JSON.parse(fs.readFileSync(this.pjPath, 'utf8'));
            const hasCliScript = ((_a = packageJson === null || packageJson === void 0 ? void 0 : packageJson.scripts) === null || _a === void 0 ? void 0 : _a.mgnl) !== undefined;
            if (!hasCliScript) {
                logger === null || logger === void 0 ? void 0 : logger.info(i18nInstance.t('init--info-adding-mgnl-script'));
                if (!packageJson.scripts) {
                    packageJson.scripts = {};
                }
                packageJson.scripts.mgnl = 'node node_modules/@magnolia/cli';
                fs.writeFileSync(this.pjPath, JSON.stringify(packageJson, null, '\t'), 'utf8');
                this.configurationSummary.push(i18nInstance.t('init--summary-mgnl-script-added'));
            }
        });
    }
    ensureConfigFileIsValid() {
        return __awaiter(this, void 0, void 0, function* () {
            const packageJson = JSON.parse(fs.readFileSync(this.pjPath, 'utf8'));
            const isEsModule = (packageJson === null || packageJson === void 0 ? void 0 : packageJson.type) === 'module';
            const configExists = fs.existsSync(this.configPath);
            if (configExists) {
                yield this.ensureConfigPackagesInstalled();
                try {
                    yield import(pathToFileURL(this.configPath).href);
                }
                catch (e) {
                    this.deferredErrors.push(i18nInstance.t('init--error-config-file-corrupted', {
                        filePath: this.configPath,
                        errorMsg: e.message,
                    }));
                }
            }
            else {
                yield handleMGNLConfigFile(!isEsModule);
                this.configurationSummary.push(i18nInstance.t(isEsModule
                    ? 'init--summary-config-js-created'
                    : 'init--summary-config-mjs-created'));
            }
        });
    }
    extractPackageNamesFromConfig() {
        const configContent = fs.readFileSync(this.configPath, 'utf8');
        const packageNames = [];
        const importRegex = /import\s+.+?from\s+['"]([^'"]+)['"]/g;
        let match;
        while ((match = importRegex.exec(configContent)) !== null) {
            const packageName = match[1];
            if (!packageName.startsWith('.') && !packageName.startsWith('/')) {
                packageNames.push(packageName);
            }
        }
        return packageNames;
    }
    ensureConfigPackagesInstalled() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!fs.existsSync(this.configPath)) {
                return;
            }
            const packageNames = this.extractPackageNamesFromConfig();
            if (packageNames.length === 0) {
                return;
            }
            const packageJson = JSON.parse(fs.readFileSync(this.pjPath, 'utf8'));
            const devDependencies = (packageJson === null || packageJson === void 0 ? void 0 : packageJson.devDependencies) || {};
            const dependencies = (packageJson === null || packageJson === void 0 ? void 0 : packageJson.dependencies) || {};
            const missingPackages = packageNames.filter((pkg) => !devDependencies[pkg] && !dependencies[pkg]);
            if (missingPackages.length === 0) {
                return;
            }
            logger === null || logger === void 0 ? void 0 : logger.info(i18nInstance.t('init--info-installing-config-packages', {
                count: missingPackages.length,
            }));
            const packageManager = determinePackageManager();
            const installFlag = packageManager === 'npm' ? '--save-dev' : '--dev';
            for (const packageName of missingPackages) {
                const success = yield installPackage(packageManager, `${packageName}@latest`, packageName, [installFlag]);
                if (success) {
                    this.configurationSummary.push(i18nInstance.t('init--summary-package-installed', {
                        packageName,
                    }));
                }
            }
        });
    }
    handleHAProjectSetup() {
        return __awaiter(this, void 0, void 0, function* () {
            logger === null || logger === void 0 ? void 0 : logger.info(i18nInstance.t('init--info-configuring-ha'));
            let haCliAvailable = false;
            let haAvailable = false;
            try {
                yield execa('ha-cli', ['--version'], { buffer: true });
                haCliAvailable = true;
            }
            catch (_a) {
                logger === null || logger === void 0 ? void 0 : logger.warn(i18nInstance.t('init--warn-ha-cli-not-available'));
            }
            if (haCliAvailable) {
                try {
                    yield execa('ha', ['--version'], { buffer: true });
                    haAvailable = true;
                }
                catch (_b) {
                    logger === null || logger === void 0 ? void 0 : logger.warn(i18nInstance.t('init--warn-ha-not-available'));
                }
            }
            if (!haCliAvailable || !haAvailable) {
                const missingCommands = [];
                if (!haCliAvailable)
                    missingCommands.push('ha-cli');
                if (!haAvailable)
                    missingCommands.push('ha');
                logger === null || logger === void 0 ? void 0 : logger.warn(i18nInstance.t('init--warn-ha-missing-commands', {
                    commands: missingCommands.join(', '),
                }));
                logger === null || logger === void 0 ? void 0 : logger.warn(i18nInstance.t('init--info-ha-installation-url'));
                logger === null || logger === void 0 ? void 0 : logger.warn(i18nInstance.t('init--info-ha-manual-install-instructions'));
                this.configurationSummary.push(i18nInstance.t('init--summary-ha-manual-setup-required'));
                return;
            }
            try {
                logger === null || logger === void 0 ? void 0 : logger.info(i18nInstance.t('init--info-running-ha-install'));
                logger === null || logger === void 0 ? void 0 : logger.info(i18nInstance.t('init--info-ha-may-prompt-credentials'));
                yield execa('ha', ['install'], {
                    cwd: process.cwd(),
                    stdio: 'inherit',
                });
                this.configurationSummary.push(i18nInstance.t('init--summary-ha-install-completed'));
            }
            catch (error) {
                logger === null || logger === void 0 ? void 0 : logger.error(i18nInstance.t('init--error-ha-install-failed', {
                    errorMsg: error instanceof Error ? error.message : String(error),
                }));
                logger === null || logger === void 0 ? void 0 : logger.info(i18nInstance.t('init--info-ha-manual-install-fallback'));
                this.configurationSummary.push(i18nInstance.t('init--summary-ha-install-failed'));
            }
        });
    }
    showSummary() {
        logger === null || logger === void 0 ? void 0 : logger.info(i18nInstance.t('init--info-success'));
        if (this.configurationSummary.length > 0) {
            logger === null || logger === void 0 ? void 0 : logger.info(i18nInstance.t('init--summary-actions'));
            this.configurationSummary.forEach((action) => {
                logger === null || logger === void 0 ? void 0 : logger.info(`  â€¢ ${action}`);
            });
        }
        const packageManager = determinePackageManager();
        const addPluginCommand = packageManager === 'yarn'
            ? 'yarn mgnl add-plugin <plugin-name>'
            : 'npm run mgnl -- add-plugin <plugin-name>';
        logger === null || logger === void 0 ? void 0 : logger.info(i18nInstance.t('init--info-next-steps'));
        logger === null || logger === void 0 ? void 0 : logger.info(i18nInstance.t('init--info-add-plugins', {
            command: addPluginCommand,
        }));
        logger === null || logger === void 0 ? void 0 : logger.info(i18nInstance.t('init--info-documentation'));
        // eslint-disable-next-line no-console
        console.log('');
        if (this.deferredErrors.length > 0) {
            this.deferredErrors.forEach((error) => {
                logger === null || logger === void 0 ? void 0 : logger.error(error);
            });
        }
    }
}
