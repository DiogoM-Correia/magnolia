var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { PluginTemplate } from '@magnolia/cli-plugin-template';
import fs from 'fs-extra';
import path from 'path';
import { execa } from 'execa';
import JSON5 from 'json5';
import { BEAUTIFY_OPTIONS } from '@magnolia/cli-helper/general-utils';
import { initI18n } from '@magnolia/cli-helper/i18n';
import beautifyModule from 'js-beautify';
import { fileURLToPath } from 'url';
import { getMgnlConfigPath } from '@magnolia/cli-helper/config';
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const { js_beautify } = beautifyModule;
const i18nNamespace = 'add-plugin';
class AddPluginError extends Error {
    constructor(message) {
        super(message);
        this.message = message;
    }
}
export default class AddPlugin extends PluginTemplate {
    constructor(args) {
        super();
        this.name = 'add-plugin';
        this.usage = '<plugin> [<pluginArgs]';
        this.pjPath = path.join(process.cwd(), 'package.json');
        this.i18nInstance = initI18n(this.name, i18nNamespace, path.join(__dirname, 'locales'));
        this.description = this.i18nInstance.t('add-plugin--description');
        this.version = args.version;
        this.loggerConfig = args.loggerConfig;
        this.configPath = getMgnlConfigPath();
    }
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            try {
                const { pluginSource, pluginArgs } = this.validateArgs();
                yield this.addPlugin(pluginSource, pluginArgs);
            }
            catch (e) {
                if (e instanceof AddPluginError) {
                    (_a = this.logger) === null || _a === void 0 ? void 0 : _a.error(e.message);
                }
                else if (e instanceof Error) {
                    (_b = this.logger) === null || _b === void 0 ? void 0 : _b.error(this.i18nInstance.t('add-plugin--error-non-mgnl-error', {
                        errorMsg: e.message,
                    }));
                }
                else {
                    throw e;
                }
            }
        });
    }
    stop() {
        return Promise.resolve(undefined);
    }
    init(logger) {
        this.logger = logger;
    }
    validateArgs() {
        if (process.argv.length <= 3) {
            throw new AddPluginError(this.i18nInstance.t('add-plugin--error-parameter-missing'));
        }
        const pluginSource = process.argv[3];
        if (pluginSource === '') {
            throw new AddPluginError(this.i18nInstance.t('add-plugin--error-parameter-missing'));
        }
        let pluginArgs = process.argv[4];
        if (pluginArgs !== undefined && pluginArgs !== '') {
            try {
                JSON5.parse(pluginArgs);
            }
            catch (_a) {
                throw new AddPluginError(this.i18nInstance.t('add-plugin--error-cannot-parse-plugin-args', {
                    pluginArgs: pluginArgs,
                }));
            }
        }
        else if (pluginArgs === undefined) {
            pluginArgs = '';
        }
        if (!fs.existsSync(this.configPath)) {
            throw new AddPluginError(this.i18nInstance.t('add-plugin--error-no-mgnl-config'));
        }
        if (!fs.existsSync(this.pjPath)) {
            throw new AddPluginError(this.i18nInstance.t('add-plugin--error-no-package-json'));
        }
        return {
            pluginArgs: pluginArgs,
            pluginSource: pluginSource,
        };
    }
    addPlugin(pluginSource, pluginArgs) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            const packageName = yield this.installPluginFromSource(pluginSource);
            const configContent = js_beautify(fs.readFileSync(this.configPath).toString().trim(), BEAUTIFY_OPTIONS);
            let className = this.parseClassNameFromPackage(packageName, configContent);
            if (this.isPluginAlreadyInstalled(className, packageName, pluginSource, configContent)) {
                return;
            }
            if (!this.isClassNameAvailable(className, configContent)) {
                const newClassName = this.appendNumToClassName(className, configContent);
                (_a = this.logger) === null || _a === void 0 ? void 0 : _a.warn(this.i18nInstance.t('add-plugin--warn-using-other-className', {
                    className: className,
                    newImportStr: this.buildImportString(newClassName, packageName),
                    importStr: this.buildImportString(className, packageName),
                }));
                className = newClassName;
            }
            yield this.modifyConfig(className, pluginArgs, packageName, configContent);
        });
    }
    execaWrapper(name, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield execa(name, options);
        });
    }
    installPluginFromSource(packageName) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            const previousDependencies = this.getPJDependencies();
            let installProcess;
            try {
                (_a = this.logger) === null || _a === void 0 ? void 0 : _a.info(this.i18nInstance.t('add-plugin--info-installing-package', {
                    name: packageName,
                }));
                const packageManager = this.getPackageManager();
                installProcess = yield this.execaWrapper(packageManager.name, [
                    packageManager.command,
                    packageManager.flag,
                    packageName,
                ]);
            }
            catch (e) {
                throw new AddPluginError(this.i18nInstance.t('add-plugin--error-installing-package', {
                    name: packageName,
                    errorMsg: e.message,
                }));
            }
            const currentDependencies = this.getPJDependencies();
            let newDeps = Object.keys(currentDependencies).filter((key) => !Object.prototype.hasOwnProperty.call(previousDependencies, key));
            if (installProcess.exitCode !== 0) {
                throw new AddPluginError(this.i18nInstance.t('add-plugin--error-cannot-verify-installation', {
                    name: packageName,
                }));
            }
            else if (newDeps.length === 0 && installProcess.exitCode === 0) {
                const { scope, name } = this.parseScopeAndName(packageName);
                const installedPackagePath = path.join(process.cwd(), 'node_modules', scope, name);
                if (fs.existsSync(installedPackagePath)) {
                    newDeps = [packageName];
                }
                else {
                    throw new AddPluginError(this.i18nInstance.t('add-plugin--error-cannot-verify-installation-no-fail'));
                }
            }
            else if (newDeps.length > 1) {
                throw new AddPluginError(this.i18nInstance.t('add-plugin--error-multiple-new-deps'));
            }
            (_b = this.logger) === null || _b === void 0 ? void 0 : _b.info(this.i18nInstance.t('add-plugin--info-installed', {
                name: packageName,
            }));
            return this.stripVersion(newDeps[0]);
        });
    }
    parseClassNameFromPackage(newPackage, configContent) {
        const createTmpClassName = () => {
            var _a;
            let tmpClasName = 'NewPlugin';
            if (!this.isClassNameAvailable(tmpClasName, configContent)) {
                tmpClasName = this.appendNumToClassName(tmpClasName, configContent);
            }
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.warn(this.i18nInstance.t('add-plugin--warn-cannot-get-plugins-class-name', {
                className: tmpClasName,
            }));
            return tmpClasName;
        };
        const { scope, name } = this.parseScopeAndName(newPackage);
        const distPath = path.join(process.cwd(), 'node_modules', scope, name, 'dist');
        const indexPath = path.join(distPath, 'index.js');
        if (!fs.existsSync(indexPath)) {
            return createTmpClassName();
        }
        const indexContent = fs.readFileSync(indexPath).toString();
        const importFileName = indexContent.match(/from\s+['"].\/(.+?)['"]/);
        if (importFileName === null || importFileName[1] === null) {
            return createTmpClassName();
        }
        const classFilePath = path.join(distPath, importFileName[1]);
        if (!fs.existsSync(classFilePath) ||
            !fs.statSync(classFilePath).isFile()) {
            return createTmpClassName();
        }
        const classPathContent = fs.readFileSync(classFilePath).toString();
        const classNamePattern = /export\s+default\s+class\s+(.+)\s+extends/;
        const classNameMatch = classPathContent.match(classNamePattern);
        if (classNameMatch === null || classNameMatch[1] === null) {
            return createTmpClassName();
        }
        return classNameMatch[1];
    }
    isPluginAlreadyInstalled(className, packageName, pluginSource, configContent) {
        var _a, _b;
        const importPattern = new RegExp(`import\\s+(.+)\\s+from\\s+["']${packageName}["']`);
        const importMatch = configContent.match(importPattern);
        if (importMatch === null) {
            return false;
        }
        if (importMatch[1] !== className) {
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.warn(this.i18nInstance.t('add-plugin--warn-plugin-exists-with-wrong-className', {
                pluginSource: pluginSource,
                found: importMatch[0],
                expected: this.buildImportString(className, packageName),
            }));
            return true;
        }
        if (importMatch[1] === className) {
            (_b = this.logger) === null || _b === void 0 ? void 0 : _b.info(this.i18nInstance.t('add-plugin--info-plugin-exists', {
                pluginSource: pluginSource,
            }));
            return true;
        }
        return false;
    }
    isClassNameAvailable(className, configContent) {
        const classNamePattern = new RegExp(`(import|new)\\s+${className}`);
        return !classNamePattern.test(configContent);
    }
    appendNumToClassName(className, configContent) {
        let newClassName = className;
        for (let counter = 2; counter < 1000; counter++) {
            newClassName = `${className}${counter}`;
            const classNamePattern = new RegExp(`(import|new)\\s+${newClassName}`);
            if (!classNamePattern.test(configContent)) {
                break;
            }
        }
        if (newClassName === className) {
            throw new AddPluginError(this.i18nInstance.t('add-plugin--error-fix-className-fail', {
                className: className,
            }));
        }
        return newClassName;
    }
    modifyConfig(className, pluginArgs, packageName, configContent) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c;
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.info(this.i18nInstance.t('add-plugin--info-modifying-mgnl-conf'));
            configContent =
                this.buildImportString(className, packageName) + configContent;
            const exportDefaultPattern = /(export\s+default\s+\{)([\s\S]*?)(}(?![^}]*});?)/;
            if (!configContent.match(exportDefaultPattern)) {
                throw new AddPluginError(this.i18nInstance.t('add-plugin--error-modifying-mgnl-conf'));
            }
            let updatedConfigContent = '';
            const newPluginStr = `\nnew ${className}(${pluginArgs})`;
            const pluginsPattern = /(plugins\s*:\s*)(\[)([^\]]*?)(])/;
            if (!configContent.match(pluginsPattern)) {
                updatedConfigContent = configContent.replace(exportDefaultPattern, (_, p1, p2, p3) => {
                    const pluginsArrayStr = `plugins: [${newPluginStr}]`;
                    const sep = p2.trim() !== '' ? ',' : '';
                    return `${p1}${pluginsArrayStr}${sep}${p2}${p3}`;
                });
            }
            else {
                updatedConfigContent = configContent.replace(pluginsPattern, (_, p1, p2, p3, p4) => {
                    const sep = p3.trim() !== '' ? ',' : '';
                    return `${p1}${p2}${newPluginStr}${sep}${p3}${p4}`;
                });
            }
            if (updatedConfigContent !== '') {
                fs.writeFileSync(this.configPath, js_beautify(updatedConfigContent.trim(), BEAUTIFY_OPTIONS));
                (_b = this.logger) === null || _b === void 0 ? void 0 : _b.info(this.i18nInstance.t('add-plugin--info-mgnl-conf-modified', {
                    className: className,
                }));
                (_c = this.logger) === null || _c === void 0 ? void 0 : _c.info(this.i18nInstance.t('add-plugin--info-plugin-run-mgnl'));
            }
            else {
                throw new AddPluginError(this.i18nInstance.t('add-plugin--error-modifying-mgnl-conf'));
            }
        });
    }
    getPJDependencies() {
        if (!fs.existsSync(this.pjPath)) {
            throw new AddPluginError(this.i18nInstance.t('add-plugin--error-no-package-json'));
        }
        try {
            const packageJson = JSON.parse(fs.readFileSync(this.pjPath).toString());
            return Object.assign(Object.assign({}, (packageJson.dependencies || {})), (packageJson.devDependencies || {}));
        }
        catch (_a) {
            throw new AddPluginError(this.i18nInstance.t('add-plugin--error-package-json-parse'));
        }
    }
    getPackageManager(baseDirectory = process.cwd()) {
        const yarnLockPath = path.join(baseDirectory, 'yarn.lock');
        if (fs.existsSync(yarnLockPath)) {
            return { name: 'yarn', command: 'add', flag: '--dev' };
        }
        return { name: 'npm', command: 'install', flag: '--save-dev' };
    }
    buildImportString(className, packageName) {
        return `import ${className} from "${packageName}"`;
    }
    parseScopeAndName(newPackage) {
        let scope = '';
        let name = '';
        // eslint-disable-next-line no-useless-escape
        const match = newPackage.match(/^(?:@([^@\/]+)\/)?([^@]+)@?(.+)?$/);
        if (match) {
            scope = match[1] || '';
            name = match[2] || '';
        }
        if (name === '') {
            throw new AddPluginError(this.i18nInstance.t('add-plugin--error-cannot-parse-installed-package-name'));
        }
        if (scope !== '') {
            scope = '@' + scope;
        }
        return { scope: scope, name: name };
    }
    stripVersion(newPackage) {
        const { scope, name } = this.parseScopeAndName(newPackage);
        return scope !== '' ? `${scope}/${name}` : name;
    }
}
