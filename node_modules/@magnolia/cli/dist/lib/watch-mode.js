var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { PluginTemplate } from '@magnolia/cli-plugin-template';
import path from 'path';
import { initI18n } from '@magnolia/cli-helper/i18n';
import { fileURLToPath } from 'url';
import { getMgnlConfigPath, getMgnlConfig } from '@magnolia/cli-helper/config';
import { Option } from 'commander';
import watch from 'glob-watcher';
import { CreateError } from '@magnolia/cli-helper';
import fs from 'fs-extra';
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const i18nNamespace = 'watch-mode';
const EXCLUDED_PATTERNS = [
    '**/node_modules/**',
    '**/.git/**',
    '**/dist/**',
    '**/build/**',
    '**/mgnl.error.log',
];
class WatchModeError extends Error {
    constructor(message) {
        super(message);
        this.name = 'WatchModeError';
    }
}
export default class WatchMode extends PluginTemplate {
    constructor(args) {
        super();
        this.name = 'watch-mode';
        this.usage = '[<pluginArgs>]';
        this.pjPath = path.join(process.cwd(), 'package.json');
        this.watchers = [];
        this.pendingFiles = new Map();
        this.pendingFileActions = new Map();
        this.batchTimers = new Map();
        this.batchDelay = 500;
        this.pluginQueue = [];
        this.isProcessingQueue = false;
        this.i18nInstance = initI18n(this.name, i18nNamespace, path.join(__dirname, 'locales'));
        this.description = this.i18nInstance.t('description');
        this.version = args.version;
        this.loggerConfig = args.loggerConfig;
        this.options = [
            new Option('-uc, --use-config [configs...]', this.i18nInstance.t('option-use-config-description')),
        ];
        this.configPath = getMgnlConfigPath();
        this.allPlugins = args.allPlugins;
    }
    parseUseConfigValues(configs) {
        var _a;
        const result = {};
        const defaultWatchPaths = ['**/*.yaml'];
        for (const config of configs) {
            const parts = config.split('::');
            const pluginName = parts[0];
            if (!this.allPlugins.find((p) => p.constructor.name === pluginName)) {
                (_a = this.logger) === null || _a === void 0 ? void 0 : _a.warn(this.i18nInstance.t('warn-plugin-not-found-use-config', {
                    pluginName: pluginName,
                }));
                continue;
            }
            if (!result[pluginName]) {
                result[pluginName] = [];
            }
            if (parts.length === 1) {
                result[pluginName].push(...defaultWatchPaths);
            }
            else {
                const watchPaths = parts.slice(1);
                const validatedPaths = this.validateAndFilterPaths(watchPaths, pluginName, defaultWatchPaths);
                result[pluginName].push(...validatedPaths);
            }
        }
        return result;
    }
    isPathExcluded(path, excluded) {
        return excluded.some((excludePattern) => {
            const normalizedPath = path.replace(/\\/g, '/');
            const normalizedPattern = excludePattern.replace(/\\/g, '/');
            const pattern = normalizedPattern
                .replace(/\*\*/g, '.*')
                .replace(/\*/g, '[^/]*');
            const regex = new RegExp(pattern);
            return (regex.test(normalizedPath) ||
                normalizedPath.includes(normalizedPattern.replace(/\*\*/g, '').replace(/\*/g, '')));
        });
    }
    validateAndFilterPaths(watchPaths, pluginName, defaultWatchPaths) {
        var _a, _b;
        const validPaths = [];
        for (const path of watchPaths) {
            if (this.isPathExcluded(path, EXCLUDED_PATTERNS)) {
                (_a = this.logger) === null || _a === void 0 ? void 0 : _a.warn(this.i18nInstance.t('warn-excluded-path-specified', {
                    path: path,
                    pluginName: pluginName,
                }));
            }
            else {
                validPaths.push(path);
            }
        }
        if (validPaths.length > 0) {
            return validPaths;
        }
        else {
            (_b = this.logger) === null || _b === void 0 ? void 0 : _b.warn(this.i18nInstance.t('info-using-default-paths', {
                pluginName: pluginName,
            }));
            return defaultWatchPaths;
        }
    }
    parseConfigFileValues() {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c;
            const result = {};
            const defaultWatchPaths = ['**/*.yaml'];
            if (!this.logger) {
                throw new Error('Logger not initialized');
            }
            const config = yield getMgnlConfig(this.logger);
            const watchModeConfig = config.watchMode || {};
            if (Object.keys(watchModeConfig).length === 0) {
                throw new CreateError(`${this.i18nInstance.t('error-no-config-found')}\n\n${this.i18nInstance.t('info-config-setup-example')}\n\n${this.i18nInstance.t('info-use-config-example')}`);
            }
            for (const [pluginName, settings] of Object.entries(watchModeConfig)) {
                if (!this.allPlugins.find((p) => p.constructor.name === pluginName)) {
                    (_a = this.logger) === null || _a === void 0 ? void 0 : _a.warn(this.i18nInstance.t('warn-plugin-not-found-config', {
                        pluginName: pluginName,
                    }));
                    continue;
                }
                if (!settings ||
                    typeof settings !== 'object' ||
                    settings.enabled === false) {
                    continue;
                }
                let watchPaths = (_b = settings.watchPaths) !== null && _b !== void 0 ? _b : defaultWatchPaths;
                if (typeof watchPaths === 'string')
                    watchPaths = [watchPaths];
                if (!Array.isArray(watchPaths)) {
                    (_c = this.logger) === null || _c === void 0 ? void 0 : _c.warn(this.i18nInstance.t('warn-invalid-watchpaths', {
                        pluginName: pluginName,
                    }));
                    continue;
                }
                const validatedPaths = this.validateAndFilterPaths(watchPaths, pluginName, defaultWatchPaths);
                result[pluginName] = validatedPaths;
            }
            return result;
        });
    }
    start(options) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c;
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.info(this.i18nInstance.t('info-running'));
            let validPlugins = {};
            const configPath = getMgnlConfigPath();
            if (!fs.existsSync(configPath)) {
                throw new CreateError(this.i18nInstance.t('error-no-mgnl-config'));
            }
            if (options.useConfig && options.useConfig.length > 0) {
                validPlugins = this.parseUseConfigValues(options.useConfig);
            }
            else {
                validPlugins = yield this.parseConfigFileValues();
            }
            if (Object.keys(validPlugins).length === 0) {
                (_b = this.logger) === null || _b === void 0 ? void 0 : _b.error(`${this.i18nInstance.t('error-no-valid-configuration')}\n\n${this.i18nInstance.t('info-config-setup-example')}\n\n${this.i18nInstance.t('info-use-config-example')}`);
                return;
            }
            for (const [pluginName, watchPaths] of Object.entries(validPlugins)) {
                (_c = this.logger) === null || _c === void 0 ? void 0 : _c.info(this.i18nInstance.t('info-plugin-will-fire', {
                    pluginName: pluginName,
                    watchPaths: watchPaths.join(', '),
                }));
                const gw = watch(watchPaths, {
                    ignored: EXCLUDED_PATTERNS,
                });
                gw.on('add', (filePath) => this.onFile('add', pluginName, filePath));
                gw.on('change', (filePath) => this.onFile('change', pluginName, filePath));
                gw.on('unlink', (filePath) => this.onFile('unlink', pluginName, filePath));
                this.watchers.push(gw);
            }
            // eslint-disable-next-line no-console
            console.log('');
            return new Promise(() => { });
        });
    }
    onFile(event, pluginName, filePath) {
        const action = event === 'add'
            ? 'created'
            : event === 'change'
                ? 'changed'
                : 'deleted';
        if (!this.pendingFiles.has(pluginName)) {
            this.pendingFiles.set(pluginName, new Set());
        }
        if (!this.pendingFileActions.has(pluginName)) {
            this.pendingFileActions.set(pluginName, new Map());
        }
        this.pendingFiles.get(pluginName).add(filePath);
        this.pendingFileActions.get(pluginName).set(filePath, action);
        if (this.batchTimers.has(pluginName)) {
            clearTimeout(this.batchTimers.get(pluginName));
        }
        const timer = setTimeout(() => {
            this.processBatch(pluginName);
        }, this.batchDelay);
        this.batchTimers.set(pluginName, timer);
    }
    processBatch(pluginName) {
        const filePaths = this.pendingFiles.get(pluginName);
        const fileActions = this.pendingFileActions.get(pluginName);
        if (!filePaths || filePaths.size === 0) {
            return;
        }
        const fileArray = Array.from(filePaths);
        const fileActionMap = new Map(fileActions || []);
        this.pendingFiles.delete(pluginName);
        this.pendingFileActions.delete(pluginName);
        this.batchTimers.delete(pluginName);
        this.pluginQueue.push(() => {
            fileArray.forEach((filePath) => {
                var _a;
                const action = fileActionMap.get(filePath) || 'changed';
                (_a = this.logger) === null || _a === void 0 ? void 0 : _a.info(this.i18nInstance.t('info-file-changed', {
                    filePath: filePath,
                    action: action,
                    pluginName: pluginName,
                }));
            });
            return this.runPlugin(pluginName, fileArray);
        });
        this.processQueue();
    }
    processQueue() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isProcessingQueue) {
                return;
            }
            this.isProcessingQueue = true;
            try {
                while (this.pluginQueue.length > 0) {
                    const pluginTask = this.pluginQueue.shift();
                    if (pluginTask) {
                        yield pluginTask();
                    }
                }
            }
            finally {
                this.isProcessingQueue = false;
            }
        });
    }
    runPlugin(pluginName_1, filePath_1) {
        return __awaiter(this, arguments, void 0, function* (pluginName, filePath, options = {}) {
            var _a, _b, _c;
            try {
                const pluginTemplate = this.allPlugins.find((p) => {
                    var _a;
                    const name = ((_a = p.constructor) === null || _a === void 0 ? void 0 : _a.name) || p.name;
                    return name === pluginName;
                });
                if (!pluginTemplate) {
                    throw new WatchModeError(this.i18nInstance.t('error-plugin-not-found', {
                        pluginName: pluginName,
                    }));
                }
                const PluginConstructor = pluginTemplate.constructor;
                const plugin = new PluginConstructor();
                if (typeof plugin.start !== 'function') {
                    throw new WatchModeError(this.i18nInstance.t('error-plugin-no-start-method', {
                        pluginName: pluginName,
                    }));
                }
                if (typeof plugin.init === 'function' && this.logger) {
                    plugin.init(this.logger);
                }
                const originalArgv = process.argv;
                const cleanedArgv = this.cleanupProcessArgv(originalArgv);
                process.argv = cleanedArgv;
                const sourceArray = Array.isArray(filePath) ? filePath : [filePath];
                yield plugin.start(Object.assign(Object.assign({}, options), { source: sourceArray, watchMode: true }));
                process.argv = originalArgv;
                (_a = this.logger) === null || _a === void 0 ? void 0 : _a.info(this.i18nInstance.t('info-plugin-completed', {
                    pluginName: pluginName,
                }));
            }
            catch (error) {
                if (error instanceof Error) {
                    (_b = this.logger) === null || _b === void 0 ? void 0 : _b.error(this.i18nInstance.t('error-plugin-failed', {
                        pluginName: pluginName,
                        errorMessage: error.message,
                    }));
                }
                else {
                    (_c = this.logger) === null || _c === void 0 ? void 0 : _c.error(this.i18nInstance.t('error-plugin-unknown-error', {
                        pluginName: pluginName,
                    }));
                }
            }
        });
    }
    cleanupProcessArgv(argv) {
        const watchModeOptions = [];
        this.options.forEach((option) => {
            if (option.short) {
                watchModeOptions.push(option.short);
            }
            if (option.long) {
                watchModeOptions.push(option.long);
            }
        });
        const cleaned = [];
        for (let i = 0; i < argv.length; i++) {
            const arg = argv[i];
            if (watchModeOptions.includes(arg)) {
                if (arg === '-uc' || arg === '--use-config') {
                    i++;
                    while (i < argv.length && !argv[i].startsWith('-')) {
                        i++;
                    }
                    i--;
                }
                else {
                    i++;
                }
                continue;
            }
            else {
                cleaned.push(arg);
            }
        }
        return cleaned;
    }
    stop() {
        var _a;
        this.watchers.forEach((w) => w.close());
        this.batchTimers.forEach((timer) => clearTimeout(timer));
        this.batchTimers.clear();
        this.pluginQueue.length = 0;
        this.isProcessingQueue = false;
        this.pendingFiles.clear();
        this.pendingFileActions.clear();
        (_a = this.logger) === null || _a === void 0 ? void 0 : _a.info(this.i18nInstance.t('info-stopped'));
        return Promise.resolve();
    }
    init(logger) {
        this.logger = logger;
    }
}
