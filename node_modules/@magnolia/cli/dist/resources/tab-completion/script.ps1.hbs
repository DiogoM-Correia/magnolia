# mgnl-v5-tabcompletion-version 1.0.0
################## Helper Functions ##################
function Find-MgnlConfig {
    param(
        [string]$startDir,
        [string]$configFileRelativePath,
        [string]$requiredFile
    )
    $currentDir = $startDir
    while ($currentDir -ne [System.IO.Path]::GetPathRoot($currentDir)) {
        $configFile = Join-Path $currentDir $configFileRelativePath
        $packageFile = Join-Path $currentDir $requiredFile
        if ((Test-Path $configFile) -and (Test-Path $packageFile)) {
            return $currentDir
        }
        $currentDir = Split-Path $currentDir -Parent
    }
    return $null
}

function Get-ModTime {
    param (
        [string]$file
    )
    if (Test-Path $file) {
        return (Get-Item $file).LastWriteTime
    }
    else {
        return [datetime]::MinValue
    }
}

function Get-Hash {
    param(
        [string]$value
    )
    $md5 = [System.Security.Cryptography.MD5CryptoServiceProvider]::new()
    $bytes = [System.Text.Encoding]::UTF8.GetBytes($value)
    $hashBytes = $md5.ComputeHash($bytes)
    $hash = [System.BitConverter]::ToString($hashBytes) -replace '-', ''
    return $hash
}

function Generate-CacheFilename {
    param(
        [string]$configPath
    )
    $hash = Get-Hash $configPath
    $tempDir = Join-Path $env:TEMP "mgnl-v5"
    if (-not (Test-Path $tempDir)) {
        New-Item -ItemType Directory -Path $tempDir | Out-Null
    }
    return Join-Path $tempDir "tab_completion_cache_$hash"
}

function Run-NodeScript {
    param(
        [string]$fullConfigPath
    )
    $unixFilePath = $fullConfigPath -replace '\\', '/'
    $nodeCode = @"
import config from 'file:///$unixFilePath';
if (config) {
  const result = [];
  const pluginsWithParam = [];
  const options = [];
  if (config.tabCompletion === false) {
    console.log('<optout/>');
  }
  if (config.tabCompletion && config.plugins) {
    const plugins = config.plugins;
    for (let i = 0; i < plugins.length; i++) {
      const plugin = plugins[i];
      result.push('<plugin>'+plugin.name+'</plugin>\n');
      if (plugin.usage && plugin.usage[0] === '<') {
        pluginsWithParam.push('<plugin>'+plugin.name+'</plugin>\n');
      }
      if (plugin.options?.length) {
        options.push('<'+plugin.name+'>\n');
        for (let j = 0; j < plugin.options.length; j++) {
          const option = plugin.options[j];
          options.push('<option>'+option.long+'|'+option.short+'|'+(option.flags.includes('<') ? '1' : '0')+'</option>\n');
        }
        options.push('</'+plugin.name+'>\n');
      }
    }
    options.push('<tab-completion>\n');
    options.push('<option>--enable|-e|0</option>\n');
    options.push('<option>--disable|-d|0</option>\n');
    options.push('<option>--uninstall|-u|0</option>\n');
    options.push('<option>--reinstall|-r|0</option>\n');
    options.push('</tab-completion>\n');
    options.push('<watch-mode>\n');
    options.push('<option>--use-config|-uc|0</option>\n');
    options.push('</watch-mode>\n');
    console.log('<config>\n<plugins>\n'+result.join('')+'<plugin>help</plugin>\n<plugin>add-plugin</plugin>\n<plugin>watch-mode</plugin>\n<plugin>tab-completion</plugin>\n</plugins>\n<pluginsWithParam>\n'+pluginsWithParam.join('')+'</pluginsWithParam>\n<options>\n'+options.join('')+'</options>\n</config>');
  }
} else {
  process.exit(1);
}
"@
    $nodeCodeSingleLine = $nodeCode -replace "(`r`n|`n)", " "
    $nodeCommand = "node --input-type=module -e `"$nodeCodeSingleLine`""
    $output = & cmd.exe /c $nodeCommand
    return $output
}

function Extract-Commands {
    param(
        [string]$output
    )
    $match = [regex]::Match($output, "<plugins>(.*?)<\/plugins>", [System.Text.RegularExpressions.RegexOptions]::Singleline)
    if ($match.Success) {
        $plugins = [regex]::Matches($match.Groups[1].Value, "<plugin>(.*?)<\/plugin>") |
                ForEach-Object { $_.Groups[1].Value }
        return $plugins -join " "
    }
    return ""
}

function Extract-PluginsWithParam {
    param(
        [string]$output
    )
    $match = [regex]::Match($output, "<pluginsWithParam>(.*?)<\/pluginsWithParam>", [System.Text.RegularExpressions.RegexOptions]::Singleline)
    if ($match.Success) {
        $plugins = [regex]::Matches($match.Groups[1].Value, "<plugin>(.*?)<\/plugin>") |
                ForEach-Object { $_.Groups[1].Value }
        return $plugins -join " "
    }
    return ""
}

function Handle-FlagsCompletion {
    param(
        [string[]]$opts,
        [string]$cur,
        [string]$prev,
        [int]$pos,
        [int]$flagStartIndex,
        [string[]]$words
    )
    $usedOpts = @()
    if ($pos -gt 1) {
        foreach ($opt_entry in $opts) {
            $parts = $opt_entry -split '\|'
            $longOpt = $parts[0]
            $shortOpt = $parts[1]
            $requiresParam = [int]$parts[2]
            if ($prev -eq $longOpt -or $prev -eq $shortOpt) {
                try {
                    $cwdMatches = Get-ChildItem -Path "$cur*" -ErrorAction SilentlyContinue | ForEach-Object { $_.Name }
                } catch {
                    $cwdMatches = @()
                }
                if (($requiresParam -eq 1 -and $cur -eq "") -or $cur.StartsWith(".") -or $cur.StartsWith("/") -or (($cur -ne "") -and $cwdMatches)) {
                    if ($cur -eq "") {
                        $files = Get-ChildItem -Path "./" -Name -ErrorAction SilentlyContinue | ForEach-Object { "./$_" }
                        return $files
                    }
                    else {
                        $files = Get-ChildItem -Path "$cur*" -Name -ErrorAction SilentlyContinue
                        return $files
                    }
                }
            }
        }
    }
    for ($i = $flagStartIndex; $i -lt $words.Count; $i++) {
        foreach ($opt_entry in $opts) {
            $parts = $opt_entry -split '\|'
            $longOpt = $parts[0]
            $shortOpt = $parts[1]
            if ($words[$i] -eq $longOpt -or $words[$i] -eq $shortOpt) {
                $usedOpts += $longOpt
            }
        }
    }
    $unusedOpts = @()
    foreach ($opt_entry in $opts) {
        $parts = $opt_entry -split '\|'
        $longOpt = $parts[0]
        $shortOpt = $parts[1]
        if (($usedOpts -notcontains $longOpt) -and ($usedOpts -notcontains $shortOpt)) {
            $unusedOpts += $longOpt
            $unusedOpts += $shortOpt
        }
    }
    return $unusedOpts | Where-Object { $_ -like "$cur*" }
}

function Load-FlagsOfCurCommand {
    param(
        [string]$command,
        [string]$scriptOutput,
        [int]$offset,
        [int]$flagStartIndex,
        [string[]]$words,
        [int]$currentPosition,
        [string]$wordToComplete
    )
    if ($command -eq "add-plugin") {
        if (($words.Count - $offset) -eq ($flagStartIndex - 1)) {
            $flags = @()
        }
        else {
            try {
                $npmSearchOutput = npm search '@magnolia/cli-' --json | ConvertFrom-Json
                $pluginNames = $npmSearchOutput | ForEach-Object { $_.name } | Where-Object { $_ -match '^@magnolia/cli-.*-plugin$' }
                $packageJson = Get-Content -Raw -Path "package.json" | ConvertFrom-Json
                $installedPlugins = $packageJson.dependencies.PSObject.Properties.Name |
                        Where-Object { $_ -match '^@magnolia/cli-.*-plugin$' }
                $availablePlugins = $pluginNames | Where-Object { $installedPlugins -notcontains $_ }
                $flags = $availablePlugins
            }
            catch {
                $flags = @()
            }
        }
        return $flags | Where-Object { $_ -like "$wordToComplete*" }
    }
    else {
        $pattern = "<$command>(.*?)<\/$command>"
        $match = [regex]::Match($scriptOutput, $pattern, [System.Text.RegularExpressions.RegexOptions]::Singleline)
        $flagsText = @()
        if ($match.Success) {
            $optionMatches = [regex]::Matches($match.Groups[1].Value, "<option>(.*?)<\/option>")
            foreach ($m in $optionMatches) {
                $flagsText += $m.Groups[1].Value
            }
        }
        if (-not $flagsText) {
            return @()
        }
        $opts = $flagsText
        return Handle-FlagsCompletion -opts $opts -cur $wordToComplete -prev $words[$words.Count - 1] -pos $currentPosition -flagStartIndex $flagStartIndex -words $words
    }
}

function FindAndLoadMgnlConfig {
    $global:scriptOutput = ""
    $global:commands = ""
    $notInProject = $false
    $configFileSuffix = "mgnl.config.js"
    $startDir = (Get-Location).Path
    $configDir = Find-MgnlConfig -startDir $startDir -configFileRelativePath $configFileSuffix -requiredFile "package.json"
    if (-not $configDir) {
        $configFileSuffix = "node_modules/@magnolia/cli/mgnl.config.js"
        $configDir = Find-MgnlConfig -startDir $startDir -configFileRelativePath $configFileSuffix -requiredFile "package.json"
        if (-not $configDir -and (Get-Command mgnl -ErrorAction SilentlyContinue)) {
            $mgnlCommand = Get-Command mgnl -ErrorAction SilentlyContinue
            if ($mgnlCommand) {
                $mgnlPath = $mgnlCommand.Source
                $resolvedItem = Get-Item $mgnlPath -Force
                if ($resolvedItem -and $resolvedItem.Target) {
                    $resolved = $resolvedItem.Target
                    $cliBase = Split-Path $resolved -Parent
                    $defaultConfig = Join-Path $cliBase "node_modules/@magnolia/cli/dist/mgnl.config.js"
                    if (Test-Path $defaultConfig) {
                        $notInProject = $true
                        $configDir = Split-Path $defaultConfig -Parent
                        $configFileSuffix = "mgnl.config.js"
                    }
                    else {
                        return $false
                    }
                }
                else {
                    return $false
                }
            }
            else {
                return $false
            }
        }
        elseif (-not $configDir) {
            return $false
        }
    }
    $fullConfigPath = Join-Path $configDir $configFileSuffix
    $cacheFile = Generate-CacheFilename -configPath $fullConfigPath
    $configModTime = Get-ModTime -file $fullConfigPath
    $pjModTime = Get-ModTime -file (Join-Path $configDir "package.json")
    $cacheModTime = Get-ModTime -file $cacheFile
    if ((Test-Path $cacheFile) -and ($cacheModTime -ge $configModTime -and $cacheModTime -ge $pjModTime)) {
        $scriptOutput = Get-Content -Path $cacheFile -Raw
    }
    else {
        $scriptOutput = Run-NodeScript -fullConfigPath $fullConfigPath
        if ($scriptOutput) {
            $scriptOutput | Out-File -FilePath $cacheFile -Encoding utf8
        }
    }
    if ($scriptOutput -match "<optout\/>") {
        $global:commands = $scriptOutput
    }
    else {
        $global:commands = Extract-Commands -output $scriptOutput
        if ($notInProject -eq $true) {
            $global:commands = (($global:commands -split "\s+") | Where-Object { $_ -notmatch '^(add-plugin)$' }) -join " "
        }
    }
    $global:scriptOutput = $scriptOutput
    return $true
}

################## Main Logic ##################
function TabComplete-Mgnl {
    param(
        [string]$wordToComplete,
        [string]$commandAst,
        [int]$cursorPosition
    )
    $words = $commandAst -split '\s+'
    if ($words[0] -eq "npm") {
        $platform = "npm"
        if ($words[1] -eq "run" -and $words[2] -eq "mgnl") {
            $mode = "local"
            $offset = 3
            $flagStartIndex = 5
        }
        else {
            return @()
        }
    }
    elseif ($words[0] -eq "yarn") {
        $platform = "yarn"
        if ($words[1] -eq "run" -and $words[2] -eq "mgnl") {
            $mode = "local"
            $offset = 3
            $flagStartIndex = 4
        }
        elseif ($words.Count -ge 2 -and $words[1] -eq "mgnl") {
            $mode = "global"
            $offset = 2
            $flagStartIndex = 3
        }
        else {
            return @()
        }
    }
    elseif ($words[0] -eq "mgnl") {
        $platform = "cli"
        $mode = "global"
        $offset = 1
        $flagStartIndex = 2
    }
    else {
        return @()
    }
    $pos = $words.Count - $offset
    $prev = if ($words.Count -gt 1) { $words[-2] } else { "" }
    if (-not (FindAndLoadMgnlConfig)) {
        return @()
    }
    if ($global:commands -match "<optout\/>") {
        return @()
    }
    $suggestions = $global:commands -split "\s+"
    if (($mode -eq "local") -and ($platform -eq "npm")) {
        $suggestions = @("`"--`"") + $suggestions
    }
    $lastWordHasNoTrailingSpace = $wordToComplete -ne ""
    if (($pos -eq 0) -or (($pos -eq 1) -and $lastWordHasNoTrailingSpace)) {
        return $suggestions | Where-Object { $_ -like "$wordToComplete*" }
    }
    elseif ($pos -gt 0) {
        $commandsWithParam = Extract-PluginsWithParam -output $global:scriptOutput
        if ($platform -eq "yarn") {
            $curcommand = $words[$offset]
            if (($commandsWithParam -match "\b$curcommand\b") -and $pos -eq 1) {
                return @("name ")
            }
            return Load-FlagsOfCurCommand -command $curcommand -scriptOutput $global:scriptOutput `
                         -offset $offset -flagStartIndex $flagStartIndex -words $words `
                         -currentPosition $words.Count -wordToComplete $wordToComplete
        }
        elseif ($mode -eq "local") {
            $firstArg = $words[$offset]
            $secondArg = if ($words.Count -ge ($offset+2)) { $words[$offset+1] } else { "" }
            $thirdArg = if ($words.Count -ge ($offset+3)) { $words[$offset+2] } else { "" }
            if (( $firstArg -eq "`"--`"" -and $secondArg -and $global:commands -match "\b$secondArg\b" ) -or
                ( $secondArg -eq "`"--`"" -and $global:commands -match "\b$firstArg\b" ) -or
                ( $thirdArg -eq "`"--`"" -and $commandsWithParam -match "\b$firstArg\b" )) {
                $curcommand = ""
                if ($global:commands -match "\b$firstArg\b") {
                    $curcommand = $firstArg
                }
                elseif ($secondArg -and $global:commands -match "\b$secondArg\b") {
                    $curcommand = $secondArg
                }
                if (($commandsWithParam -match "\b$curcommand\b") -and (($pos -eq 2) -and (-not $lastWordHasNoTrailingSpace))) {
                    return @("name ")
                }
                return Load-FlagsOfCurCommand -command $curcommand -scriptOutput $global:scriptOutput `
                         -offset $offset -flagStartIndex $flagStartIndex -words $words `
                         -currentPosition $words.Count -wordToComplete $wordToComplete
            }
            elseif ($firstArg -eq "`"--`"") {
                return ($global:commands -split "\s+") | Where-Object { $_ -like "$wordToComplete*" }
            }
            elseif ($global:commands -match "\b$firstArg\b") {
                return @("`"--`"")
            }
            else {
                return $suggestions | Where-Object { $_ -like "$wordToComplete*" }
            }
        }
        else {
            $curcommand = $words[$offset]
            if ($commandsWithParam -match "\b$curcommand\b") {
                if ($pos -eq 1) {
                    return @("name ")
                }
                else {
                    return Load-FlagsOfCurCommand -command $curcommand -scriptOutput $global:scriptOutput `
                             -offset $offset -flagStartIndex $flagStartIndex -words $words `
                             -currentPosition $words.Count -wordToComplete $wordToComplete
                }
            }
            else {
                return Load-FlagsOfCurCommand -command $curcommand -scriptOutput $global:scriptOutput `
                         -offset $offset -flagStartIndex $flagStartIndex -words $words `
                         -currentPosition $words.Count -wordToComplete $wordToComplete
            }
        }
    }
    return @()
}

# Register the Register-ArgumentCompleter for both npm-run and global usage.
{{#if local}}
Register-ArgumentCompleter -Native -CommandName 'npm' -ScriptBlock {
    param($wordToComplete, $commandAst, $cursorPosition)
    $words = $commandAst -split '\s+'
    if ($words.Count -ge 3 -and $words[0] -eq "npm" -and $words[1] -eq "run" -and $words[2] -eq "mgnl") {
        TabComplete-Mgnl -wordToComplete $wordToComplete -commandAst $commandAst -cursorPosition $cursorPosition
    }
    else {
        @()
    }
}

Register-ArgumentCompleter -Native -CommandName 'yarn' -ScriptBlock {
    param($wordToComplete, $commandAst, $cursorPosition)
    $words = $commandAst -split '\s+'
    if ( ($words.Count -ge 3 -and $words[0] -eq "yarn" -and $words[1] -eq "run" -and $words[2] -eq "mgnl") -or
         ($words.Count -ge 2 -and $words[0] -eq "yarn" -and $words[1] -eq "mgnl") ) {
        TabComplete-Mgnl -wordToComplete $wordToComplete -commandAst $commandAst -cursorPosition $cursorPosition
    }
    else {
        @()
    }
}
{{/if}}
{{#if global}}
Register-ArgumentCompleter -Native -CommandName 'mgnl' -ScriptBlock {
    param($wordToComplete, $commandAst, $cursorPosition)
    TabComplete-Mgnl -wordToComplete $wordToComplete -commandAst $commandAst -cursorPosition $cursorPosition
}
{{/if}}
