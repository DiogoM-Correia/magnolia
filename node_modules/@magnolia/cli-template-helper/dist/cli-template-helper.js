var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import path from 'path';
import { fileURLToPath } from 'url';
import { PluginTemplate } from '@magnolia/cli-plugin-template';
import { ExitPromptError } from '@inquirer/core';
import fs from 'fs-extra';
import { helper } from './lib/helper.js';
import inquirer from 'inquirer';
import ora from 'ora';
import { npmRepository } from './lib/npm-repository.js';
import decompress from 'decompress';
import npmFetch from 'npm-registry-fetch';
import { simpleGit } from 'simple-git';
import axios from 'axios';
import { PrototypeHelper } from './lib/prototype-helper.js';
import { addAvailability } from './lib/add-availability.js';
import { initI18n, modifyConfig, prepareLightModule, checkFlagsValue, getMgnlConfig, CreateError, prependNumbersToChoices, } from '@magnolia/cli-helper';
const __dirname = path.dirname(fileURLToPath(import.meta.url));
export let logger;
export let i18nInstance = {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    t(key, options) {
        return key;
    },
};
export default class TemplateHelperPlugin extends PluginTemplate {
    constructor(args, context) {
        super();
        this.options = [];
        this.tempFolder = path.join(process.cwd(), '.temp');
        this.configUpdates = {
            sharedProps: {},
            pluginProps: {},
        };
        this.usingMessages = {
            prototype: '',
            type: '',
        };
        i18nInstance = initI18n('template-helper', 'translation', path.join(__dirname, 'lib/locales'));
        this.pluginArgs = args || {};
        this.context = context;
    }
    init(winstonLogger) {
        return __awaiter(this, void 0, void 0, function* () {
            logger = winstonLogger;
        });
    }
    start(options, args) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const validatedArgs = yield this.validateAndResolveArgs(options, args);
                validatedArgs.frameworkFolder =
                    yield this.downloadFramework(validatedArgs);
                yield this.startFramework(validatedArgs, options);
            }
            catch (e) {
                if (e instanceof CreateError) {
                    logger === null || logger === void 0 ? void 0 : logger.error(e.message);
                }
                else if (e instanceof ExitPromptError) {
                    return;
                }
                else if (e instanceof Error) {
                    logger === null || logger === void 0 ? void 0 : logger.error(i18nInstance.t('error-non-mgnl-error', {
                        errorMsg: e.message,
                    }));
                }
                else {
                    throw e;
                }
            }
            finally {
                fs.rmSync(this.tempFolder, { recursive: true, force: true });
            }
        });
    }
    stop() {
        return __awaiter(this, void 0, void 0, function* () {
            fs.rmSync(this.tempFolder, { recursive: true, force: true });
        });
    }
    validateAndResolveArgs(options, args) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            if (Array.isArray(args) && args.length > 1) {
                throw new CreateError(`${i18nInstance.t('error-multiple-arguments-provided')}\n\nUsage: ${this.name} ${this.usage}`);
            }
            const componentType = this.context.slice(0, -1);
            const hasArgs = Array.isArray(args) && args.length > 0;
            const rawArg = hasArgs ? args[0] : process.argv[3];
            const shouldPrompt = !hasArgs && (!rawArg || rawArg.trim() === '');
            const nameToParse = shouldPrompt
                ? yield helper.promptForComponentName(componentType)
                : helper.parseName(rawArg, componentType);
            const { subDirs, originalName, componentName } = nameToParse;
            checkFlagsValue(this.options, options);
            const { lightModulePath, newLightModulesPath, newLightModule } = yield prepareLightModule(options, this.pluginArgs, logger);
            if (newLightModulesPath) {
                this.configUpdates.sharedProps.lightModulesPath =
                    newLightModulesPath;
            }
            if (newLightModule) {
                this.configUpdates.pluginProps.lightModule = newLightModule;
            }
            let prototype;
            if (options.prototype) {
                prototype = options.prototype;
                this.usingMessages.prototype = 'info-using-option-prototype';
            }
            else if (this.pluginArgs.prototype) {
                prototype = this.pluginArgs.prototype;
                this.usingMessages.prototype = 'info-using-config-prototype';
            }
            const config = yield getMgnlConfig(logger);
            const spaPath = this.context === 'components'
                ? config.componentsSpaPath
                : config.pagesSpaPath;
            const { type, componentMappingFilePath } = config;
            const templateHelperArgs = {
                componentName,
                originalName,
                type,
                componentMappingFilePath: componentMappingFilePath
                    ? path.resolve(process.cwd(), componentMappingFilePath)
                    : componentMappingFilePath,
                spaPath: spaPath ? path.resolve(process.cwd(), spaPath) : spaPath,
                lightModulePath,
                framework: this.pluginArgs.framework,
                prototype,
                templateData: this.pluginArgs.templateData,
                templateArgs: this.pluginArgs.templateArgs,
                context: this.context,
                frameworkFolder: '',
                frameworkType: 'npm',
                subDirs,
            };
            if (templateHelperArgs.framework !== undefined) {
                if (fs.existsSync(templateHelperArgs.framework) &&
                    fs.statSync(templateHelperArgs.framework).isDirectory()) {
                    templateHelperArgs.frameworkType = 'dir';
                }
                else if (fs.existsSync(templateHelperArgs.framework) &&
                    templateHelperArgs.framework.endsWith('.tgz')) {
                    templateHelperArgs.frameworkType = 'tgz';
                }
                else if (/\.git$/.test(templateHelperArgs.framework)) {
                    templateHelperArgs.frameworkType = 'git';
                }
                else if (/^https?:\/\//.test(templateHelperArgs.framework)) {
                    templateHelperArgs.frameworkType = 'http';
                }
            }
            if (templateHelperArgs.framework === undefined) {
                templateHelperArgs.framework = yield this.getFw();
                this.configUpdates.pluginProps.framework =
                    templateHelperArgs.framework;
            }
            else if (templateHelperArgs.frameworkType === 'npm') {
                try {
                    if (!templateHelperArgs.framework.startsWith('@magnolia/cli') &&
                        !this.pluginArgs.trustedFramework) {
                        const { trustFramework } = yield inquirer.prompt([
                            {
                                type: 'confirm',
                                name: 'trustFramework',
                                message: i18nInstance.t('inquirer-prompt-confirm-unsafe-fw', { framework: templateHelperArgs.framework }),
                            },
                        ]);
                        if (trustFramework) {
                            this.configUpdates.pluginProps.trustedFramework = true;
                        }
                        else {
                            process.exit(1);
                        }
                    }
                    const npmPackage = yield npmFetch.json(npmRepository.getRepositoryUrl(templateHelperArgs.framework));
                    // @ts-ignore
                    const npmPackageTarball = (_a = npmPackage === null || npmPackage === void 0 ? void 0 : npmPackage.dist) === null || _a === void 0 ? void 0 : _a.tarball;
                    if (npmPackageTarball === undefined) {
                        logger === null || logger === void 0 ? void 0 : logger.warn(i18nInstance.t('error-fw-no-tarball', {
                            framework: templateHelperArgs.framework,
                        }));
                        templateHelperArgs.framework = yield this.getFw();
                        this.configUpdates.pluginProps.framework =
                            templateHelperArgs.framework;
                    }
                }
                catch (_b) {
                    logger === null || logger === void 0 ? void 0 : logger.warn(i18nInstance.t('error-fw-do-not-exists', {
                        framework: templateHelperArgs.framework,
                    }));
                    templateHelperArgs.framework = yield this.getFw();
                    this.configUpdates.pluginProps.framework =
                        templateHelperArgs.framework;
                }
            }
            return templateHelperArgs;
        });
    }
    getFw() {
        return __awaiter(this, void 0, void 0, function* () {
            const availableFwSpinner = ora().start(i18nInstance.t('ora-find-packages'));
            let availableFrameworks;
            try {
                availableFrameworks =
                    yield npmRepository.fetchAvailablePrototypesPackages();
                availableFwSpinner.stop();
            }
            catch (e) {
                availableFwSpinner.fail();
                throw e;
            }
            if (availableFrameworks.length === 0) {
                throw new CreateError(i18nInstance.t('error-no-available-fw'));
            }
            const nameChoices = availableFrameworks.map((item) => item.name);
            const { selectedName } = yield inquirer.prompt([
                {
                    type: 'list',
                    name: 'selectedName',
                    message: i18nInstance.t('inquirer-prompt-choose-fw-template'),
                    choices: prependNumbersToChoices(nameChoices),
                },
            ]);
            const selectedFw = availableFrameworks.find((item) => item.name === selectedName);
            let fwVersion = '';
            if (Array.isArray(selectedFw.versions)) {
                const { selectedVersion } = yield inquirer.prompt([
                    {
                        type: 'list',
                        name: 'selectedVersion',
                        message: i18nInstance.t('inquirer-prompt-choose-fw-version'),
                        choices: prependNumbersToChoices(selectedFw.versions.reverse()),
                    },
                ]);
                fwVersion = selectedVersion;
            }
            else {
                fwVersion = selectedFw.versions;
            }
            return `${selectedName}@${fwVersion}`;
        });
    }
    downloadFramework(args) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            const downloadingFwSpinner = ora().start(i18nInstance.t('ora-downloading-fw', { framework: args.framework }));
            const downloadTarball = (url, destDir) => __awaiter(this, void 0, void 0, function* () {
                const tarballFile = path.join(destDir, url.split('/').pop() || 'framework');
                fs.ensureFileSync(tarballFile);
                try {
                    const res = yield axios.get(url, {
                        method: 'get',
                        responseType: 'stream',
                    });
                    if (res.status !== 200) {
                        throw new CreateError(i18nInstance.t('error-download-status', {
                            downloadUrl: url,
                            status: res.status,
                        }));
                    }
                    const target = fs.createWriteStream(tarballFile);
                    res.data.pipe(target);
                    yield new Promise((resolve) => {
                        target.on('finish', () => {
                            resolve(path.join('.', tarballFile));
                        });
                        target.on('error', (error) => {
                            target.close();
                            throw new CreateError(error.message);
                        });
                        res.data.on('error', (error) => {
                            target.close();
                            throw new CreateError(error.message);
                        });
                    });
                    return yield decompressTarball(tarballFile, destDir);
                }
                catch (error) {
                    throw new CreateError(error.message);
                }
            });
            const decompressTarball = (tarballFile, destPath) => __awaiter(this, void 0, void 0, function* () {
                if (destPath === undefined) {
                    destPath = tarballFile.replace('.tgz', '');
                }
                fs.ensureDirSync(destPath);
                yield decompress(tarballFile, destPath);
                return path.join(destPath, 'package');
            });
            const createDestFolder = (framework, sep, cb) => {
                let fwName = framework.split(sep).pop() || 'framework';
                if (cb) {
                    fwName = cb(fwName);
                }
                const destFolder = path.join(this.tempFolder, fwName);
                fs.ensureDirSync(destFolder);
                return destFolder;
            };
            let frameworkFolder;
            if (args.frameworkType === 'dir') {
                const destPath = createDestFolder(args.framework, path.sep);
                fs.copySync(args.framework, destPath);
                frameworkFolder = destPath;
            }
            else if (args.frameworkType === 'tgz') {
                frameworkFolder = yield decompressTarball(args.framework, createDestFolder(args.framework, path.sep, (fwName) => fwName.replace('.tgz', '')));
            }
            else if (args.frameworkType === 'git') {
                const destPath = createDestFolder(args.framework, path.sep, (fwName) => fwName.replace('.git', ''));
                yield simpleGit().clone(args.framework, destPath);
                frameworkFolder = destPath;
            }
            else if (args.frameworkType === 'http') {
                frameworkFolder = yield downloadTarball(args.framework, createDestFolder(args.framework, '/', (fwName) => fwName.replace('.tgz', '')));
            }
            else {
                const tempFile = path.join(this.tempFolder, `${Date.now().toString()}.tgz`);
                const npmPackage = yield npmFetch
                    .json(npmRepository.getRepositoryUrl(args.framework))
                    .catch(() => {
                    downloadingFwSpinner.fail();
                    throw new CreateError(i18nInstance.t('error-fw-do-not-exists', {
                        framework: args.framework,
                    }));
                });
                // @ts-ignore
                const npmPackageTarballUrl = (_a = npmPackage === null || npmPackage === void 0 ? void 0 : npmPackage.dist) === null || _a === void 0 ? void 0 : _a.tarball;
                if (npmPackageTarballUrl === undefined) {
                    throw new CreateError(i18nInstance.t('error-fw-no-tarball', {
                        framework: args.framework,
                    }));
                }
                frameworkFolder = yield downloadTarball(npmPackageTarballUrl, tempFile);
            }
            if (frameworkFolder === undefined) {
                downloadingFwSpinner.fail();
                throw new CreateError(i18nInstance.t('error-fw-not-downloaded', {
                    framework: args.framework,
                }));
            }
            else {
                downloadingFwSpinner.stop();
            }
            return frameworkFolder;
        });
    }
    startFramework(args, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const prototypeHelper = new PrototypeHelper(args.componentName, {
                originalName: args.originalName,
                lightModulePath: args.lightModulePath,
                prototype: args.prototype,
                framework: args.framework,
                type: args.type,
                templateData: args.templateData,
                templateArgs: args.templateArgs,
                componentMappingFilePath: args.componentMappingFilePath,
                spaPath: args.spaPath,
                context: args.context,
                frameworkFolder: args.frameworkFolder,
                subDirs: args.subDirs,
            }, this.usingMessages);
            logger === null || logger === void 0 ? void 0 : logger.info(i18nInstance.t('info-starting-fw', { framework: args.framework }));
            const { success, templateId, isHeadless, configUpdates } = yield prototypeHelper.start();
            this.configUpdates.sharedProps = Object.assign(Object.assign({}, this.configUpdates.sharedProps), configUpdates.sharedProps);
            this.configUpdates.pluginProps = Object.assign(Object.assign({}, this.configUpdates.pluginProps), configUpdates.pluginProps);
            yield modifyConfig(this.configUpdates, helper.getPluginName(this.context), logger);
            fs.rmSync(this.tempFolder, { recursive: true, force: true });
            if (success &&
                this.context === 'components' &&
                options.available !== undefined &&
                options.available !== false) {
                yield addAvailability.start(templateId, options.available, args.lightModulePath, isHeadless);
            }
        });
    }
}
