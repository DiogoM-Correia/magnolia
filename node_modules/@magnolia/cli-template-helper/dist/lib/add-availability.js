var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
// @ts-ignore
import path from 'path';
import fs from 'fs';
import { i18nInstance, logger } from '../cli-template-helper.js';
import { CreateError } from '@magnolia/cli-helper/general-utils';
import inquirer from 'inquirer';
import _ from 'lodash';
import YAML from 'yaml';
import { getModuleName } from '@magnolia/cli-helper';
function matchesDefinitionReferenceWithAreaPattern(val) {
    return /^([\w-/:]+)@([\w-]+)$/.exec(val);
}
function matchesDefinitionReferenceWithoutAreaPattern(val) {
    return /^([\w-/:]+)$/.exec(val);
}
/**
 * Parses a definition reference string, expected to be in a form of [<module>:][<relative_path>/]<name>[@<area_name>]
 */
function parseDefinitionReference(definitionId, moduleName) {
    const def = {
        area: '',
        module: '',
        path: '',
        name: '',
        refId: '',
    };
    const containsTargetArea = definitionId.indexOf('@') !== -1;
    if (containsTargetArea) {
        const idx = definitionId.indexOf('@');
        def.area = definitionId.substring(idx + 1);
        definitionId = definitionId.substring(0, idx);
    }
    const refIdMatcher = /^(?:([\w-]+):)?([\w-/]+\/)?([\w-]+)$/.exec(definitionId);
    if (!refIdMatcher) {
        throw new CreateError(i18nInstance.t('error-no-match-id', { id: definitionId }));
    }
    // if 'module' is not provided - then use the one passed
    const module = refIdMatcher[1] ? refIdMatcher[1] : moduleName;
    // if no slashes occur in the path/name string - assume path to be equal to the name
    let path = refIdMatcher[2]
        ? refIdMatcher[2] + refIdMatcher[3]
        : (containsTargetArea ? 'pages/' : 'components/') + refIdMatcher[3];
    if (!path.startsWith('pages/') && !path.startsWith('components/')) {
        path = 'pages/' + path;
    }
    def.module = module;
    def.path = path;
    def.name = refIdMatcher[3];
    def.refId = module + ':' + path;
    return def;
}
function ensureIsAValidLightModuleFolder(pathToModule) {
    if (!fs.existsSync(pathToModule)) {
        throw new CreateError(i18nInstance.t('error-invalid-path', { path: pathToModule }));
    }
}
function addComponentAvailability(args) {
    return __awaiter(this, void 0, void 0, function* () {
        const data = fs.readFileSync(args.templateDefinitionFilePath, 'utf-8');
        if (data.length === 0) {
            throw new CreateError(i18nInstance.t('error-empty-definition', {
                filename: args.templateDefinitionFilePath,
            }));
        }
        const yamlData = YAML.parseDocument(data, { keepSourceTokens: true });
        const yamlDataWithComponent = injectComponentAvailability(yamlData, args);
        fs.writeFileSync(args.templateDefinitionFilePath, YAML.stringify(yamlDataWithComponent, { lineWidth: 0 }), 'utf-8');
    });
}
function ensureMapExists(parentKey, key) {
    let map = parentKey.get(key);
    if (!map) {
        map = new YAML.YAMLMap();
        parentKey.set(key, map);
    }
    return map;
}
function injectComponentAvailability(yamlDoc, args) {
    const areas = ensureMapExists(yamlDoc, 'areas');
    let targetArea = areas.get(args.targetArea);
    if (!targetArea) {
        logger === null || logger === void 0 ? void 0 : logger.info(i18nInstance.t('info-availability-area-added', {
            area: args.targetArea,
            example: args.isHeadless
                ? `{${args.targetArea} && <EditableArea content={${args.targetArea}} />}`
                : `[@cms.area name=\"${args.targetArea}\"/]`,
        }));
        targetArea = new YAML.YAMLMap();
        areas.set(args.targetArea, targetArea);
    }
    const availableComponents = ensureMapExists(targetArea, 'availableComponents');
    if (!availableComponents.has(args.component.name)) {
        availableComponents.set(args.component.name, {
            id: args.component.refId,
        });
        logger === null || logger === void 0 ? void 0 : logger.info(i18nInstance.t('info-availability-added-into', {
            refId: args.component.refId,
            file: args.templateDefinitionFilePath,
        }));
    }
    else {
        logger === null || logger === void 0 ? void 0 : logger.info(i18nInstance.t('info-component-already-available', {
            refId: args.component.refId,
            file: args.templateDefinitionFilePath,
        }));
    }
    return yamlDoc;
}
function getYamlFiles(dirPath) {
    let yamlFiles = [];
    if (!fs.existsSync(dirPath)) {
        return yamlFiles;
    }
    const files = fs.readdirSync(dirPath);
    files.forEach((file) => {
        const filePath = path.join(dirPath, file);
        const stat = fs.lstatSync(filePath);
        if (stat.isDirectory()) {
            yamlFiles = yamlFiles.concat(getYamlFiles(filePath));
        }
        else if (path.extname(file).toLowerCase() === '.yaml') {
            yamlFiles.push(filePath.replace('.yaml', ''));
        }
    });
    return yamlFiles;
}
function start(component, page, lightModulePath, isHeadless) {
    return __awaiter(this, void 0, void 0, function* () {
        if (typeof page === 'boolean') {
            const lightModulesPath = path.join(lightModulePath, '..');
            let allLightModules = fs
                .readdirSync(lightModulesPath)
                .filter((name) => {
                return fs
                    .statSync(path.join(lightModulesPath, name))
                    .isDirectory();
            });
            allLightModules = allLightModules.filter((name) => {
                const hasPages = fs.existsSync(path.join(lightModulesPath, name, 'templates', 'pages'));
                const hasComponents = fs.existsSync(path.join(lightModulesPath, name, 'templates', 'components'));
                return hasPages || hasComponents;
            });
            const allLightModulesWithValues = allLightModules.reduce((acc, key) => {
                const lmPagesPath = path.join(lightModulesPath, key, 'templates', 'pages');
                const lmComponentsPath = path.join(lightModulesPath, key, 'templates', 'components');
                const availablePages = getYamlFiles(lmPagesPath).map((it) => path.relative(lmPagesPath, it.replace('.yaml', '')));
                const availableComponents = getYamlFiles(lmComponentsPath).map((it) => path.relative(lmComponentsPath, it.replace('.yaml', '')));
                if (availablePages.length > 0 ||
                    availableComponents.length > 0) {
                    acc[key] = {
                        pages: availablePages,
                        components: availableComponents,
                    };
                }
                return acc;
            }, {});
            allLightModules = Object.keys(allLightModulesWithValues);
            const promptForDirectory = (obj) => __awaiter(this, void 0, void 0, function* () {
                const choices = [];
                if (obj.type === 'page' || obj.type === 'component') {
                    choices.push(new inquirer.Separator());
                    choices.push({
                        name: i18nInstance.t('inquirer-choice-choose-different-lm'),
                        value: 'SELECT_LIGHT_MODULE',
                    });
                    choices.push({
                        name: i18nInstance.t('inquirer-choice-change-template-type'),
                        value: 'SELECT_TEMPLATE_TYPE',
                    });
                    choices.push(new inquirer.Separator());
                    const templates = obj.type === 'page'
                        ? allLightModulesWithValues[obj.lightModule].pages
                        : allLightModulesWithValues[obj.lightModule].components;
                    // From: `[lm-name]:[pages|components]/[path]` to: `[path]`
                    const componentPathMatch = /^[\w-]+:(pages|components)\/(.*)/.exec(component);
                    const componentPath = componentPathMatch
                        ? componentPathMatch[2]
                        : component;
                    choices.push(...templates.map((it) => ({
                        name: it === componentPath
                            ? `${it.replace(/\\/g, '/')} ${i18nInstance.t('inquirer-choice-newly-created-indicator')}`
                            : it.replace(/\\/g, '/'),
                        value: it,
                    })));
                }
                else if (obj.type === 'templateType') {
                    choices.push(new inquirer.Separator());
                    choices.push({
                        name: i18nInstance.t('inquirer-choice-choose-different-lm'),
                        value: 'SELECT_LIGHT_MODULE',
                    });
                    choices.push(new inquirer.Separator());
                    const lmData = allLightModulesWithValues[obj.lightModule];
                    if (lmData.pages.length > 0) {
                        choices.push({ name: 'Pages', value: 'page' });
                    }
                    if (lmData.components.length > 0) {
                        choices.push({ name: 'Components', value: 'component' });
                    }
                }
                else {
                    choices.push(new inquirer.Separator());
                    choices.push({
                        name: i18nInstance.t('inquirer-choice-skip-adding-component', { component: component }),
                        value: 'SKIP',
                    });
                    choices.push(new inquirer.Separator());
                    choices.push(...allLightModules.map((it) => ({
                        name: it.replace(/\\/g, '/'),
                        value: it.replace(/\\/g, '/'),
                    })));
                }
                const answer = yield inquirer.prompt([
                    {
                        type: 'list',
                        name: 'selectedValue',
                        message: i18nInstance.t('inquirer-prompt-choose-type', {
                            type: obj.type === 'lm'
                                ? 'light module'
                                : obj.type === 'templateType'
                                    ? 'template type'
                                    : obj.type,
                        }),
                        choices: choices,
                    },
                ]);
                if (answer.selectedValue === 'SKIP') {
                    return {
                        value: 'SKIP',
                        lightModule: undefined,
                        type: undefined,
                        templateType: undefined,
                        selected: true,
                    };
                }
                if (answer.selectedValue === 'SELECT_LIGHT_MODULE') {
                    return {
                        value: undefined,
                        lightModule: undefined,
                        type: 'lm',
                        templateType: undefined,
                        selected: false,
                    };
                }
                if (answer.selectedValue === 'SELECT_TEMPLATE_TYPE') {
                    return {
                        value: undefined,
                        lightModule: obj.lightModule,
                        type: 'templateType',
                        templateType: undefined,
                        selected: false,
                    };
                }
                else {
                    if (obj.type === 'lm') {
                        const lmData = allLightModulesWithValues[answer.selectedValue];
                        // Determine default template type based on what's available
                        let defaultTemplateType = 'templateType';
                        if (lmData.pages.length > 0 &&
                            lmData.components.length === 0) {
                            defaultTemplateType = 'page';
                        }
                        else if (lmData.components.length > 0 &&
                            lmData.pages.length === 0) {
                            defaultTemplateType = 'component';
                        }
                        return {
                            value: undefined,
                            lightModule: answer.selectedValue,
                            type: defaultTemplateType,
                            templateType: undefined,
                            selected: false,
                        };
                    }
                    else if (obj.type === 'templateType') {
                        return {
                            value: undefined,
                            lightModule: obj.lightModule,
                            type: answer.selectedValue,
                            templateType: answer.selectedValue,
                            selected: false,
                        };
                    }
                    else {
                        return {
                            value: answer.selectedValue,
                            lightModule: obj.lightModule,
                            type: obj.type,
                            templateType: obj.templateType,
                            selected: true,
                        };
                    }
                }
            });
            const selectedLightModule = path.basename(lightModulePath);
            let promptResult = {
                value: undefined,
                lightModule: selectedLightModule,
                type: 'page',
                templateType: 'page',
                selected: false,
            };
            if (allLightModulesWithValues === undefined ||
                _.isEmpty(allLightModulesWithValues)) {
                logger === null || logger === void 0 ? void 0 : logger.warn(i18nInstance.t('warn-no-pages-exists', {
                    component: component,
                    lightModulesPath: lightModulesPath,
                }));
                return;
            }
            else if (selectedLightModule !== undefined &&
                allLightModulesWithValues[selectedLightModule] === undefined) {
                logger === null || logger === void 0 ? void 0 : logger.warn(i18nInstance.t('warn-lm-has-no-page', {
                    lightModule: selectedLightModule,
                }));
                promptResult = {
                    value: undefined,
                    lightModule: undefined,
                    type: 'lm',
                    templateType: undefined,
                    selected: false,
                };
            }
            else if (selectedLightModule !== undefined) {
                // Default to pages, but if only components exist, use components
                const lmData = allLightModulesWithValues[selectedLightModule];
                if (lmData.pages.length === 0 && lmData.components.length > 0) {
                    promptResult.type = 'component';
                    promptResult.templateType = 'component';
                }
            }
            do {
                promptResult = yield promptForDirectory(promptResult);
                if (promptResult.selected) {
                    break;
                }
            } while (!promptResult.selected);
            if (promptResult.value === 'SKIP') {
                logger.info(i18nInstance.t('info-skip-adding-component', {
                    component: component,
                }));
                return;
            }
            const { chosenArea } = yield inquirer.prompt([
                {
                    type: 'input',
                    name: 'chosenArea',
                    message: i18nInstance.t('inquirer-prompt-enter-area'),
                    default: 'main',
                },
            ]);
            page = (promptResult.lightModule +
                ':' +
                promptResult.type +
                's/' +
                promptResult.value +
                '@' +
                chosenArea);
        }
        if (!matchesDefinitionReferenceWithAreaPattern(page) &&
            !matchesDefinitionReferenceWithoutAreaPattern(page)) {
            throw new CreateError(i18nInstance.t('error-unexpected-page-format', { page }));
        }
        // if no area was specified defaults to main
        if (page.indexOf('@') === -1) {
            logger === null || logger === void 0 ? void 0 : logger.info(i18nInstance.t('info-no-target-defined'));
            page = page.concat('@main');
        }
        if (page.indexOf(':') !== -1) {
            const lightModule = page.split(':')[0];
            lightModulePath = path.join(lightModulePath, '..', lightModule);
        }
        const args = {
            path: '',
            templateDefinitionFilePath: '',
            targetPage: { area: '', path: '' },
            component: {
                area: '',
                module: '',
                path: '',
                name: '',
                refId: '',
            },
            targetArea: '',
            isHeadless: isHeadless,
        };
        args.path = path.resolve(lightModulePath, '../');
        const moduleName = getModuleName(lightModulePath);
        args.component = parseDefinitionReference(component, moduleName);
        args.targetPage = parseDefinitionReference(page, moduleName);
        args.targetArea = args.targetPage.area;
        const pathToModule = lightModulePath;
        ensureIsAValidLightModuleFolder(pathToModule);
        args.templateDefinitionFilePath = path.normalize(pathToModule + '/templates/' + args.targetPage.path + '.yaml');
        if (!fs.existsSync(args.templateDefinitionFilePath)) {
            throw new CreateError(i18nInstance.t('error-page-definition-doesnt-exist', {
                file: args.templateDefinitionFilePath,
            }));
        }
        yield addComponentAvailability(args);
    });
}
export const addAvailability = {
    start,
};
