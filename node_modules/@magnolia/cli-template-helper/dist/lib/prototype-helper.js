var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import path from 'path';
import fs from 'fs-extra';
import { fileURLToPath, pathToFileURL } from 'url';
import { createRequire } from 'module';
import os from 'os';
import { i18nInstance, logger } from '../cli-template-helper.js';
import _ from 'lodash';
import { helper } from './helper.js';
import inquirer from 'inquirer';
import { CreateError } from '@magnolia/cli-helper/general-utils';
import { promptForDirOrFile } from '@magnolia/cli-helper/prompt';
import { getRelativePathToMGNLConfig } from '@magnolia/cli-helper/config';
import Handlebars from 'handlebars';
// @ts-ignore
import PromisedHandlebars from 'promised-handlebars';
const pHandlebars = PromisedHandlebars(Handlebars);
const requireFn = createRequire(import.meta.url);
const __dirname = path.dirname(fileURLToPath(import.meta.url));
pHandlebars.registerHelper('helperMissing', function (...args) {
    return __awaiter(this, void 0, void 0, function* () {
        const options = args[args.length - 1];
        const { customPlaceholder } = yield inquirer.prompt([
            {
                type: 'input',
                name: 'customPlaceholder',
                message: i18nInstance.t('inquirer-prompt-enter-value-for-placeholder', { key: options.name }),
            },
        ]);
        return new pHandlebars.SafeString(customPlaceholder);
    });
});
export class PrototypeHelper {
    constructor(name, options, usingMessages = {}) {
        this.preparedComponent = [];
        this.configUpdates = {
            sharedProps: {},
            pluginProps: {},
        };
        this.usingMessages = {};
        const lightModuleName = helper.getDestLightModuleName(options.lightModulePath);
        this.options = options;
        let templateScript = `/${lightModuleName}/templates/${options.context}`;
        if (options.subDirs) {
            templateScript = `${templateScript}/${options.subDirs}`;
        }
        this.templateData = {
            name: name,
            exportName: name,
            lightModuleName: lightModuleName,
            magnoliaHost: 'http://localhost:8080',
            templateScript: `${templateScript}/${name}.ftl`,
            modelName: _.upperFirst(_.camelCase(name)),
            lightDevModuleFolder: _.upperFirst(_.camelCase(name)),
        };
        this.templateArgs = {
            useDefaultLightModuleTemplate: true,
            removeExtension: false,
            namedImport: false,
        };
        this.usingMessages = usingMessages;
    }
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            let success = true;
            let isHeadless;
            try {
                const originalExportName = this.templateData.exportName;
                const originalName = this.options.originalName;
                const nameInCamelCase = _.lowerFirst(_.camelCase(this.templateData.name));
                if (nameInCamelCase !== originalName) {
                    logger === null || logger === void 0 ? void 0 : logger.info(i18nInstance.t('info-name-changed-for-lm-items', {
                        newName: nameInCamelCase,
                        originalName: originalName,
                    }));
                }
                this.templateData.name = nameInCamelCase;
                const pathToPrototype = yield this.getPathToPrototype();
                isHeadless = fs.readdirSync(pathToPrototype).includes('spa');
                if (isHeadless) {
                    yield this.validateHeadlessOptions();
                }
                yield this.loadPrototypeConfigFile(pathToPrototype);
                yield this.loadTemplateDataAndArgsFromOptions();
                const lmPrototypePath = yield this.getPathToPrototypeLM(pathToPrototype);
                this.templateData.dialog = yield this.getCorrectConfigValue(lmPrototypePath, 'dialogs');
                this.templateData.template = yield this.getCorrectConfigValue(lmPrototypePath, 'templates');
                yield this.prepareComponentFromPrototype(lmPrototypePath, this.options.lightModulePath);
                if (isHeadless) {
                    const nameInPascalCase = _.upperFirst(_.camelCase(this.templateData.name));
                    if (nameInPascalCase !== originalName) {
                        logger === null || logger === void 0 ? void 0 : logger.info(i18nInstance.t('info-name-changed-for-spa-items', {
                            newName: nameInPascalCase,
                            originalName: originalName,
                        }));
                    }
                    this.templateData.name = nameInPascalCase;
                    const exportNameInPascalCase = _.upperFirst(_.camelCase(this.templateData.exportName));
                    if (exportNameInPascalCase !== originalExportName &&
                        originalName !== originalExportName) {
                        logger === null || logger === void 0 ? void 0 : logger.info(i18nInstance.t('info-export-name-changed', {
                            newName: exportNameInPascalCase,
                            originalName: originalExportName,
                        }));
                    }
                    this.templateData.exportName = exportNameInPascalCase;
                    const spaPrototypePath = yield this.getPathToPrototypeSPA(pathToPrototype);
                    this.templateData.package = yield this.getProjectPJ();
                    yield this.prepareComponentFromPrototype(spaPrototypePath, this.options.spaPath);
                }
                yield this.preventDuplicates();
                yield this.create();
                if (isHeadless &&
                    this.options.componentMappingFilePath !== undefined &&
                    this.options.componentMappingFilePath !== '') {
                    const mappingObj = yield this.buildMappingObject();
                    const importObj = yield this.buildImportObject(mappingObj.name, mappingObj.postfix);
                    yield this.writeComponentMapping(importObj, mappingObj);
                }
            }
            catch (e) {
                success = false;
                logger === null || logger === void 0 ? void 0 : logger.error(e.message);
            }
            finally {
                // eslint-disable-next-line no-unsafe-finally
                return {
                    success: success,
                    type: this.options.type,
                    prototype: this.options.prototype,
                    dialogId: this.templateData.dialog,
                    templateId: this.templateData.template,
                    componentMappingFilePath: this.options.componentMappingFilePath,
                    configUpdates: this.configUpdates,
                    spaPath: this.options.spaPath,
                    isHeadless: isHeadless,
                };
            }
        });
    }
    stop(message) {
        return __awaiter(this, void 0, void 0, function* () {
            logger === null || logger === void 0 ? void 0 : logger.error(message);
            // Wait for logger to finish
            yield new Promise((resolve) => setTimeout(resolve, 500));
            process.exit(1);
        });
    }
    loadPrototypeConfigFile(pathToPrototype) {
        return __awaiter(this, void 0, void 0, function* () {
            const pathToExternalJs = path.join(pathToPrototype, 'config.js');
            if (!fs.existsSync(pathToExternalJs)) {
                return;
            }
            let configFile;
            if (os.platform() === 'win32') {
                configFile = yield import(pathToFileURL(pathToExternalJs).href);
            }
            else {
                configFile = yield import(pathToExternalJs);
            }
            for (const [key, value] of Object.entries(configFile)) {
                if (typeof value === 'function') {
                    if (key === 'getTemplateData') {
                        const prototypeTemplateData = value.bind(this)();
                        if (prototypeTemplateData !== undefined) {
                            try {
                                JSON.parse(JSON.stringify(prototypeTemplateData));
                            }
                            catch (_a) {
                                throw new CreateError(i18nInstance.t('error-while-parsing-prototype-template-data', { prototype: this.options.prototype }));
                            }
                            this.templateData = _.merge({}, this.templateData, prototypeTemplateData);
                        }
                        else {
                            logger === null || logger === void 0 ? void 0 : logger.warn(i18nInstance.t('warn-while-parsing-prototype-template-data', { prototype: this.options.prototype }));
                        }
                        continue;
                    }
                    if (key === 'getTemplateArgs') {
                        const prototypeTemplateArgs = value.bind(this)();
                        if (prototypeTemplateArgs !== undefined) {
                            try {
                                JSON.parse(JSON.stringify(prototypeTemplateArgs));
                            }
                            catch (_b) {
                                throw new CreateError(i18nInstance.t('error-while-parsing-prototype-template-args', { prototype: this.options.prototype }));
                            }
                            this.templateArgs = _.merge({}, this.templateArgs, prototypeTemplateArgs);
                        }
                        else {
                            logger === null || logger === void 0 ? void 0 : logger.warn(i18nInstance.t('warn-while-parsing-prototype-template-args', { prototype: this.options.prototype }));
                        }
                        continue;
                    }
                    if (this[key] == undefined) {
                        logger === null || logger === void 0 ? void 0 : logger.warn(i18nInstance.t('warn-exported-func-not-available', {
                            key: key,
                        }));
                        continue;
                    }
                    if (key === 'start' || key === 'stop') {
                        logger === null || logger === void 0 ? void 0 : logger.warn(i18nInstance.t('warn-reserved-func', {
                            key: key,
                        }));
                        continue;
                    }
                    if (typeof this[key] === 'function') {
                        const superFunc = this[key];
                        this[key] = (...args) => __awaiter(this, void 0, void 0, function* () {
                            const result = value.call(this, ...args, superFunc.bind(this));
                            if (result instanceof Promise) {
                                return yield result;
                            }
                            return result;
                        });
                    }
                }
            }
        });
    }
    loadTemplateDataAndArgsFromOptions() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.options.templateData !== undefined) {
                try {
                    this.options.templateData = JSON.parse(JSON.stringify(this.options.templateData));
                }
                catch (_a) {
                    throw new CreateError(i18nInstance.t('error-while-parsing-template-data'));
                }
                this.templateData = _.merge({}, this.templateData, this.options.templateData);
            }
            if (this.options.templateArgs !== undefined) {
                try {
                    this.options.templateArgs = JSON.parse(JSON.stringify(this.options.templateArgs));
                }
                catch (_b) {
                    throw new CreateError(i18nInstance.t('error-while-parsing-template-args'));
                }
                this.templateArgs = _.merge({}, this.templateArgs, this.options.templateArgs);
            }
        });
    }
    getPathToPrototype() {
        return __awaiter(this, void 0, void 0, function* () {
            const pathToFrameworkContext = path.join(this.options.frameworkFolder, this.options.context);
            if (!this.options.prototype) {
                this.options.prototype = yield helper.promptForPrototype(pathToFrameworkContext, this.options.framework);
                this.usingMessages.prototype = '';
            }
            else if (typeof this.options.prototype === 'boolean') {
                this.options.prototype = yield helper.promptForPrototype(pathToFrameworkContext, this.options.framework);
                this.usingMessages.prototype = '';
            }
            if (this.usingMessages.prototype) {
                logger === null || logger === void 0 ? void 0 : logger.info(i18nInstance.t(this.usingMessages.prototype, {
                    prototype: this.options.prototype,
                }));
            }
            let pathToPrototype = path.join(pathToFrameworkContext, this.options.prototype);
            if (!fs.existsSync(path.join(pathToFrameworkContext, this.options.prototype))) {
                logger === null || logger === void 0 ? void 0 : logger.warn(i18nInstance.t('warn-prototype-not-available', {
                    prototype: this.options.prototype,
                    framework: this.options.framework,
                }));
                this.options.prototype = yield helper.promptForPrototype(pathToFrameworkContext, this.options.framework);
                pathToPrototype = path.join(pathToFrameworkContext, this.options.prototype);
            }
            return pathToPrototype;
        });
    }
    getPathToPrototypeLM(pathToPrototype) {
        return __awaiter(this, void 0, void 0, function* () {
            let pathToPrototypeLightModule = path.join(pathToPrototype, 'light-module');
            if (!fs.existsSync(pathToPrototypeLightModule) &&
                this.templateArgs.useDefaultLightModuleTemplate) {
                pathToPrototypeLightModule = path.join(__dirname, '..', 'resources', this.options.context, 'light-module');
            }
            else if (!fs.existsSync(pathToPrototypeLightModule)) {
                throw new CreateError(i18nInstance.t('error-no-prototype-lm-provided', {
                    prototype: this.options.prototype,
                }));
            }
            return pathToPrototypeLightModule;
        });
    }
    getCorrectConfigValue(pathToPrototypeLM, configType) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            let name = this.templateData.name;
            if (this.options.subDirs) {
                name = path.posix.join(this.options.subDirs, name);
            }
            let result = `${this.templateData.lightModuleName}:${this.options.context}/${name}`;
            const configContextPath = path.join(pathToPrototypeLM, configType, this.options.context);
            if (fs.existsSync(configContextPath)) {
                const files = helper.getAllPaths(configContextPath);
                const file = (_a = files.find((f) => f.endsWith('{{name}}.yaml.hbs'))) !== null && _a !== void 0 ? _a : files[0];
                const template = pHandlebars.compile(path
                    .relative(configContextPath, file)
                    .replace(/\\+/g, '/')
                    .replace('.yaml.hbs', ''));
                const compiledRelativePath = yield template(this.templateData);
                const idPath = path.posix.join(this.options.context, (_b = this.options.subDirs) !== null && _b !== void 0 ? _b : '', compiledRelativePath);
                result = `${this.templateData.lightModuleName}:${idPath}`;
            }
            return result;
        });
    }
    validateHeadlessOptions() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.options.spaPath === undefined) {
                logger === null || logger === void 0 ? void 0 : logger.warn(i18nInstance.t('warn-spa-path-provided', {
                    context: this.options.context,
                }));
                this.options.spaPath = yield promptForDirOrFile({
                    logger,
                    createNew: true,
                    message: i18nInstance.t('inquirer-prompt-choose-spa-path', {
                        context: this.options.context,
                    }),
                });
                this.configUpdates.sharedProps[`${this.options.context}SpaPath`] =
                    getRelativePathToMGNLConfig(this.options.spaPath);
            }
            if (!fs.existsSync(this.options.spaPath)) {
                const answer = yield helper.promptForCreationOfNotExistingResource(i18nInstance.t('inquirer-prompt-confirm-create-spa', {
                    context: this.options.context,
                    path: this.options.spaPath,
                }), this.options.spaPath, 'dir');
                if (!answer) {
                    this.options.spaPath = yield promptForDirOrFile({
                        logger,
                        createNew: true,
                        message: i18nInstance.t('inquirer-prompt-choose-spa-path', {
                            context: this.options.context,
                        }),
                    });
                    this.configUpdates.sharedProps[`${this.options.context}SpaPath`] = getRelativePathToMGNLConfig(this.options.spaPath);
                }
            }
            if (this.options.componentMappingFilePath === undefined ||
                this.options.componentMappingFilePath === '') {
                if (this.options.componentMappingFilePath === undefined) {
                    this.options.componentMappingFilePath =
                        yield helper.promptForComponentsMappingFile();
                    if (this.options.componentMappingFilePath) {
                        this.configUpdates.sharedProps.componentMappingFilePath =
                            getRelativePathToMGNLConfig(this.options.componentMappingFilePath);
                    }
                }
                if (this.options.componentMappingFilePath === '') {
                    logger === null || logger === void 0 ? void 0 : logger.warn(i18nInstance.t('warn-no-cmp-file'));
                }
            }
            this.options.componentMappingFilePath = helper.getAbsolutePath(this.options.componentMappingFilePath);
            if (this.options.componentMappingFilePath !== undefined &&
                this.options.componentMappingFilePath !== '' &&
                !fs.existsSync(this.options.componentMappingFilePath)) {
                const answer = yield helper.promptForCreationOfNotExistingResource(i18nInstance.t('inquirer-prompt-confirm-create-cmp', {
                    path: this.options.componentMappingFilePath,
                }), this.options.componentMappingFilePath, 'file', helper.getDefaultComponentsMappingFileContent());
                if (!answer) {
                    this.options.componentMappingFilePath =
                        yield helper.promptForComponentsMappingFile();
                    if (this.options.componentMappingFilePath) {
                        this.configUpdates.sharedProps.componentMappingFilePath =
                            getRelativePathToMGNLConfig(this.options.componentMappingFilePath);
                    }
                }
            }
        });
    }
    getPathToPrototypeSPA(pathToPrototype) {
        return __awaiter(this, void 0, void 0, function* () {
            const availableTypes = fs.readdirSync(path.join(pathToPrototype, 'spa'));
            if (availableTypes.length === 0) {
                throw new CreateError(i18nInstance.t('error-no-types-available', {
                    prototypePath: path.join(pathToPrototype, 'spa'),
                }));
            }
            if (!this.options.type) {
                logger === null || logger === void 0 ? void 0 : logger.warn(i18nInstance.t('warn-no-type-set'));
                this.options.type = yield helper.promptForType(availableTypes, this.options.prototype);
                this.configUpdates.sharedProps.type = this.options.type;
            }
            else if (availableTypes.indexOf(this.options.type) === -1) {
                logger === null || logger === void 0 ? void 0 : logger.warn(i18nInstance.t('warn-type-not-available', {
                    type: this.options.type,
                    prototype: this.options.prototype,
                }));
                this.options.type = yield helper.promptForType(availableTypes, this.options.prototype);
                this.configUpdates.sharedProps.type = this.options.type;
            }
            const pathToSpaPrototype = path.join(pathToPrototype, 'spa', this.options.type);
            if (!fs.existsSync(pathToSpaPrototype)) {
                throw new CreateError(i18nInstance.t('error-spa-prototype-type-does-not-exist', {
                    pathToSpaPrototype: pathToSpaPrototype,
                }));
            }
            return pathToSpaPrototype;
        });
    }
    getProjectPJ() {
        return __awaiter(this, void 0, void 0, function* () {
            let currentPath = this.options.spaPath;
            while (currentPath !== path.parse(currentPath).root) {
                const packagePath = path.join(currentPath, 'package.json');
                if (fs.existsSync(packagePath)) {
                    currentPath = packagePath;
                    break;
                }
                currentPath = path.dirname(currentPath);
            }
            if (currentPath !== undefined) {
                return requireFn(currentPath);
            }
            return {};
        });
    }
    prepareComponentFromPrototype(prototypeTemplatePath, componentDestinationPath) {
        return __awaiter(this, void 0, void 0, function* () {
            prototypeTemplatePath = prototypeTemplatePath.replace(/\\+/g, '/');
            componentDestinationPath = componentDestinationPath.replace(/\\+/g, '/');
            if (!fs.existsSync(prototypeTemplatePath)) {
                return;
            }
            const isFile = fs.statSync(prototypeTemplatePath).isFile();
            if (isFile) {
                // ignore macOS .DS_store file
                if (prototypeTemplatePath.endsWith('.DS_Store')) {
                    return;
                }
                const srcContent = fs
                    .readFileSync(prototypeTemplatePath)
                    .toString();
                if (this.options.subDirs) {
                    const token = '{{name}}';
                    const subDir = this.options.subDirs;
                    const normalized = componentDestinationPath.replace(/\\+/g, '/');
                    const parts = normalized.split('/');
                    const idx = parts.findIndex((seg) => seg.includes(token));
                    if (idx !== -1) {
                        parts.splice(idx, 0, subDir);
                    }
                    else {
                        parts.push(subDir);
                    }
                    componentDestinationPath = parts.join('/');
                }
                const destPathTemplate = pHandlebars.compile(componentDestinationPath);
                const destPath = yield destPathTemplate(this.templateData);
                const contentTemplate = pHandlebars.compile(srcContent);
                const content = yield contentTemplate(this.templateData);
                const componentItem = {
                    srcPath: prototypeTemplatePath,
                    destPath: componentDestinationPath,
                    hbDestPath: destPath.replace('.hbs', ''),
                    content: srcContent,
                    hbContent: content,
                };
                this.preparedComponent.push(componentItem);
            }
            else {
                const srcPathContent = fs.readdirSync(prototypeTemplatePath);
                for (const item of srcPathContent) {
                    yield this.prepareComponentFromPrototype(path.join(prototypeTemplatePath, item), path.join(componentDestinationPath, item));
                }
            }
        });
    }
    preventDuplicates() {
        return __awaiter(this, void 0, void 0, function* () {
            const existingFiles = this.preparedComponent
                .map((it) => {
                if (fs.existsSync(it.hbDestPath)) {
                    return it.hbDestPath;
                }
            })
                .filter((path) => path !== undefined);
            if (existingFiles.length > 0) {
                logger === null || logger === void 0 ? void 0 : logger.error(i18nInstance.t('error-component-or-page-already-exists', {
                    context: _.upperFirst(this.options.context),
                    name: this.templateData.name,
                }));
                // eslint-disable-next-line no-console
                existingFiles.forEach((it) => console.log(' - ' + it));
                throw new CreateError(i18nInstance.t('error-choose-different-name'));
            }
        });
    }
    create() {
        return __awaiter(this, void 0, void 0, function* () {
            this.preparedComponent.forEach((it) => {
                const dir = path.dirname(it.hbDestPath);
                fs.mkdirSync(dir, { recursive: true });
                fs.writeFileSync(it.hbDestPath, it.hbContent);
                logger === null || logger === void 0 ? void 0 : logger.info(i18nInstance.t('info-file-created', {
                    path: it.hbDestPath,
                    name: path.basename(it.hbDestPath),
                }));
            });
        });
    }
    buildMappingObject() {
        return __awaiter(this, void 0, void 0, function* () {
            return {
                id: `${this.templateData.dialog}`,
                name: this.templateData.exportName,
                postfix: this.options.context === 'pages' ? 'Page' : 'Component',
            };
        });
    }
    buildImportObject(mappingName, mappingPostfix) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.options.componentMappingFilePath === undefined ||
                this.options.spaPath === undefined) {
                throw new CreateError(i18nInstance.t('error-no-component-mapping-file-or-spa-path-provided', { context: this.options.context }));
            }
            const preparedSpaFiles = this.preparedComponent.filter((it) => {
                var _a;
                return it.hbDestPath.startsWith(
                // eslint-disable-next-line @typescript-eslint/no-non-null-asserted-optional-chain
                (_a = this.options.spaPath) === null || _a === void 0 ? void 0 : _a.replace(/\\+/g, '/'));
            });
            let preparedComponentFile;
            if (this.templateArgs.importSource !== undefined) {
                const possibleTtFile = preparedSpaFiles.find((it) => {
                    return it.srcPath.endsWith(this.templateArgs.importSource);
                });
                if (possibleTtFile !== undefined) {
                    preparedComponentFile = possibleTtFile;
                }
                else {
                    throw new CreateError(i18nInstance.t('error-no-import-source', {
                        componentMappingFilePath: this.options.componentMappingFilePath,
                    }));
                }
            }
            else {
                if (preparedSpaFiles.length === 1) {
                    preparedComponentFile = preparedSpaFiles[0];
                }
                else {
                    const possibleImportSourceFiles = preparedSpaFiles.filter((it) => it.hbDestPath.endsWith(`.${this.options.type}`));
                    const indexFiles = possibleImportSourceFiles.filter((it) => path.basename(it.hbDestPath).startsWith('index'));
                    const componentsFiles = possibleImportSourceFiles.filter((it) => {
                        return (path
                            .basename(it.hbDestPath)
                            .startsWith(this.templateData.name) &&
                            it.hbDestPath.endsWith(`.${this.options.type}`));
                    });
                    if (indexFiles.length === 1) {
                        preparedComponentFile = indexFiles[0];
                    }
                    else if (componentsFiles.length === 1) {
                        preparedComponentFile = componentsFiles[0];
                    }
                    else {
                        throw new CreateError(i18nInstance.t('error-no-import-source', {
                            componentMappingFilePath: this.options.componentMappingFilePath,
                        }));
                    }
                }
            }
            const spaFolderPath = path.relative(path.join(this.options.componentMappingFilePath, '..'), this.options.spaPath);
            const componentFilePath = path.join(spaFolderPath, path.relative(this.options.spaPath, preparedComponentFile.hbDestPath));
            let importSource = (componentFilePath.startsWith('../')
                ? componentFilePath
                : './' + componentFilePath).replace(/\\+/g, '/');
            if (this.templateArgs.removeExtension) {
                importSource = importSource.replace(`.${this.options.type}`, '');
            }
            let exportComponentName;
            if (this.templateArgs.namedImport) {
                exportComponentName = `{ ${mappingName} as ${mappingName + mappingPostfix} }`;
            }
            else {
                exportComponentName = mappingName + mappingPostfix;
            }
            return { name: exportComponentName, source: importSource };
        });
    }
    getImportString(name, source) {
        return __awaiter(this, void 0, void 0, function* () {
            return `import ${name} from '${source}'`;
        });
    }
    getMappingString(id, name) {
        return __awaiter(this, void 0, void 0, function* () {
            return `"${id}": ${name}`;
        });
    }
    promptForPotentialDuplicity(item, condition, stringBuilder, expectedString, msgConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            if (item.first !== undefined &&
                item.second !== undefined &&
                expectedString !== '') {
                if (condition) {
                    const existingString = yield stringBuilder(item.first, item.second);
                    logger === null || logger === void 0 ? void 0 : logger.warn(i18nInstance.t('warn-expected-string-exists', {
                        type: msgConfig.type,
                        first: msgConfig.first,
                        second: msgConfig.second,
                        existingString: existingString,
                        expectedString: expectedString,
                    }));
                    const answers = yield inquirer.prompt({
                        type: 'confirm',
                        name: 'confirm',
                        message: i18nInstance.t('inquirer-prompt-confirm-add-string', { type: msgConfig.type }),
                        default: true,
                    });
                    if (answers.confirm) {
                        logger === null || logger === void 0 ? void 0 : logger.warn(i18nInstance.t('warn-add-expected-string-confirm', {
                            type: msgConfig.type,
                            path: this.options.componentMappingFilePath,
                        }));
                    }
                    else {
                        expectedString = '';
                    }
                }
                else {
                    logger === null || logger === void 0 ? void 0 : logger.info(i18nInstance.t('info-existing-expected-string', {
                        expectedString: expectedString,
                    }));
                    expectedString = '';
                }
            }
            return expectedString;
        });
    }
    getAndValidateImportString(componentMappingFileContent, importObj) {
        return __awaiter(this, void 0, void 0, function* () {
            let importString = yield this.getImportString(importObj.name, importObj.source);
            const importFromPattern = /import\s+(\w+)\s+from\s+['"](.+)['"](\s*;\s*)?/g;
            const existingImports = [];
            let importFromMatch;
            while ((importFromMatch = importFromPattern.exec(componentMappingFileContent)) !== null) {
                existingImports.push({
                    name: importFromMatch[1],
                    source: importFromMatch[2],
                });
            }
            const regexPattern = importObj.name
                .replace(/[\-\{\}\(\)\\]/g, '\\$&')
                .replace(/\s+/g, '\\s+');
            const importNameRegex = new RegExp(`^${regexPattern}$`);
            const existingImportSource = existingImports.find((it) => it.source === importObj.source);
            importString = yield this.promptForPotentialDuplicity({
                first: existingImportSource === null || existingImportSource === void 0 ? void 0 : existingImportSource.name,
                second: existingImportSource === null || existingImportSource === void 0 ? void 0 : existingImportSource.source,
            }, !importNameRegex.test((existingImportSource === null || existingImportSource === void 0 ? void 0 : existingImportSource.name) || ''), this.getImportString, importString, { type: 'import', first: 'source', second: 'name' });
            const existingImportName = existingImports.find((it) => importNameRegex.test(it.name));
            importString = yield this.promptForPotentialDuplicity({
                first: existingImportName === null || existingImportName === void 0 ? void 0 : existingImportName.name,
                second: existingImportName === null || existingImportName === void 0 ? void 0 : existingImportName.source,
            }, (existingImportName === null || existingImportName === void 0 ? void 0 : existingImportName.source) !== importObj.source, this.getImportString, importString, { type: 'import', first: 'name', second: 'source' });
            return importString;
        });
    }
    getAndValidateMappingString(match, mappingObj) {
        return __awaiter(this, void 0, void 0, function* () {
            let mappingString = yield this.getMappingString(mappingObj.id, mappingObj.name + mappingObj.postfix);
            if (match !== null && match[2] !== null) {
                const existingComponentMappings = [];
                const existingComponentMappingsStr = match[2].replace(/\s+/g, '');
                const componentMappingPattern = /['"]([^'"]+)['"]:(\w+)/g;
                let componentMappingMatch;
                while ((componentMappingMatch = componentMappingPattern.exec(existingComponentMappingsStr)) !== null) {
                    existingComponentMappings.push({
                        id: componentMappingMatch[1],
                        name: componentMappingMatch[2],
                    });
                }
                const existingMappingId = existingComponentMappings.find((it) => it.id === mappingObj.id);
                mappingString = yield this.promptForPotentialDuplicity({
                    first: existingMappingId === null || existingMappingId === void 0 ? void 0 : existingMappingId.id,
                    second: existingMappingId === null || existingMappingId === void 0 ? void 0 : existingMappingId.name,
                }, (existingMappingId === null || existingMappingId === void 0 ? void 0 : existingMappingId.name) !==
                    mappingObj.name + mappingObj.postfix, this.getMappingString, mappingString, { type: 'mapping', first: 'id', second: 'name' });
                const existingMappingName = existingComponentMappings.find((it) => it.name === mappingObj.name + mappingObj.postfix);
                mappingString = yield this.promptForPotentialDuplicity({
                    first: existingMappingName === null || existingMappingName === void 0 ? void 0 : existingMappingName.id,
                    second: existingMappingName === null || existingMappingName === void 0 ? void 0 : existingMappingName.name,
                }, (existingMappingName === null || existingMappingName === void 0 ? void 0 : existingMappingName.id) !== mappingObj.id, this.getMappingString, mappingString, { type: 'mapping', first: 'name', second: 'id' });
            }
            return mappingString;
        });
    }
    promptUser(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            const answer = yield inquirer.prompt({
                type: 'confirm',
                name: 'confirm',
                message: msg,
                default: true,
            });
            return answer.confirm;
        });
    }
    writeComponentMapping(importObj, mappingObj) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.options.componentMappingFilePath === undefined ||
                this.options.spaPath === undefined) {
                throw new CreateError(i18nInstance.t('error-no-component-mapping-file-or-spa-path-provided', { context: this.options.context }));
            }
            const componentMappingPattern = /(['"]?componentMapping[s]?['"]?\s*:\s*\{)([^\}]*?)(\})/;
            const componentMappingFileContent = fs.readFileSync(this.options.componentMappingFilePath, 'utf-8');
            const componentsMappingMatch = componentMappingFileContent.match(componentMappingPattern);
            if (componentsMappingMatch === null) {
                logger === null || logger === void 0 ? void 0 : logger.warn(i18nInstance.t('warn-no-component-mapping-property', {
                    componentMappingFilePath: this.options.componentMappingFilePath,
                }));
                const createMappingObject = yield this.promptUser(i18nInstance.t('inquirer-prompt-confirm-add-cmp-obj'));
                if (createMappingObject) {
                    logger === null || logger === void 0 ? void 0 : logger.warn(i18nInstance.t('warn-add-cmp-obj-confirm', {
                        path: this.options.componentMappingFilePath,
                    }));
                }
                else {
                    logger === null || logger === void 0 ? void 0 : logger.warn(i18nInstance.t('warn-add-import-manually', {
                        componentMappingFilePath: this.options.componentMappingFilePath,
                        importStr: yield this.getImportString(importObj.name, importObj.source),
                        componentMapping: yield this.getMappingString(mappingObj.id, mappingObj.name + mappingObj.postfix),
                    }));
                    return;
                }
            }
            const importString = yield this.getAndValidateImportString(componentMappingFileContent, importObj);
            const mappingString = yield this.getAndValidateMappingString(componentsMappingMatch, mappingObj);
            let newComponentMappingFileContent;
            if (componentsMappingMatch !== null) {
                newComponentMappingFileContent =
                    (importString !== '' ? importString + '\n' : '') +
                        componentMappingFileContent.replace(componentMappingPattern, (_, p1, p2, p3) => {
                            const emptySpacesCount = p2.trim() !== ''
                                ? helper.getEmptyPrefix(p2)
                                : '    ';
                            const separator = p2.trim() !== '' &&
                                mappingString.trim() !== '' &&
                                !p2.trim().endsWith(',')
                                ? ',\n'
                                : '\n';
                            return `${p1}${p2.replace(/\s+$/, '')}${separator}${emptySpacesCount}${mappingString}\n${helper.getHalfEmptyPrefix(emptySpacesCount)}${p3}`;
                        });
            }
            else {
                newComponentMappingFileContent =
                    (importString !== '' ? importString + '\n' : '') +
                        (componentMappingFileContent !== null && componentMappingFileContent !== void 0 ? componentMappingFileContent : '') +
                        helper.getDefaultComponentsMappingFileContent(mappingString);
            }
            fs.writeFileSync(this.options.componentMappingFilePath, newComponentMappingFileContent, 'utf-8');
            if (importString !== '' && mappingString !== '') {
                logger === null || logger === void 0 ? void 0 : logger.info(i18nInstance.t('info-added-import-and-component-mapping', {
                    importStr: importString,
                    componentMapping: mappingString,
                    componentMappingFilePath: this.options.componentMappingFilePath,
                }));
            }
            else if (importString !== '') {
                logger === null || logger === void 0 ? void 0 : logger.info(i18nInstance.t('info-added-import-or-component-mapping', {
                    text: importString,
                    componentMappingFilePath: this.options.componentMappingFilePath,
                }));
            }
            else if (mappingString !== '') {
                logger === null || logger === void 0 ? void 0 : logger.info(i18nInstance.t('info-added-import-or-component-mapping', {
                    text: mappingString,
                    componentMappingFilePath: this.options.componentMappingFilePath,
                }));
            }
        });
    }
}
