var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { PluginTemplate } from '@magnolia/cli-plugin-template';
import { Option } from 'commander';
import { createRequire } from 'module';
const requireFn = createRequire(import.meta.url);
const pkg = requireFn('./package.json');
import inquirer from 'inquirer';
import filenamify from 'filenamify';
import axios from 'axios';
import { extract } from './lib/extract.js';
import { downloadBundle } from './lib/download.js';
import { PostCommands, } from './types/types.js';
import { installDependencies } from './lib/install.js';
import path from 'path';
import fs from 'fs-extra';
import process from 'process';
import { askForCredentials, copyDownloadedFile, handleLightModulesFolder, handleLightModulesPathInTemplate, initializeNodeProject, } from './lib/helper.js';
import { compileCustomPrompts, evaluateCustomPrompts, } from './lib/extensions.js';
import { addConfigProps } from './lib/config-helper.js';
import { installAdditionalPlugins } from './lib/config-helper.js';
import { checkFlagsValue, CreateError, prependNumbersToChoices, } from '@magnolia/cli-helper/general-utils';
import { initI18n } from '@magnolia/cli-helper/i18n';
import { fileURLToPath } from 'url';
const __dirname = path.dirname(fileURLToPath(import.meta.url));
const extensionsPath = path.resolve('./extensions/extension.yaml');
export let logger;
export let i18nInstance = {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    t(key, options) {
        return key;
    },
};
export default class JumpstartPlugin extends PluginTemplate {
    constructor() {
        super();
        this.name = 'jumpstart';
        this.version = pkg.version;
        this.usage = '[name] [options]';
        this.authProfiles = {};
        i18nInstance = initI18n(this.name, 'translation', path.join(__dirname, 'lib/locales'));
        this.description = i18nInstance.t('description');
        this.options = [
            new Option('-m, --magnolia <version>', i18nInstance.t('option-magnolia-description')),
            new Option('-s, --snapshot', i18nInstance.t('option-snapshot-description')),
            new Option('-t, --template <name>', i18nInstance.t('option-template-description')),
            new Option('-pt, --project-templates <source>', i18nInstance.t('option-projectTemplates-description')),
        ];
    }
    executePostCommands(bundle, file) {
        return __awaiter(this, void 0, void 0, function* () {
            const isCopied = copyDownloadedFile(bundle, file);
            if (!bundle.postCommand) {
                return;
            }
            for (const command of bundle.postCommand) {
                switch (command) {
                    case PostCommands.Extract:
                    case PostCommands.ExtractAndOverride:
                    case PostCommands.ExtractAndUnfold:
                        if (!isCopied) {
                            yield extract(bundle, file, command);
                        }
                        break;
                    case PostCommands.NpmInstall:
                    case PostCommands.YarnInstall:
                        yield installDependencies(bundle, command);
                        break;
                }
            }
        });
    }
    handleTemplate(template, options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (template.auth !== undefined) {
                if (typeof template.auth === 'boolean') {
                    this.credentials = yield askForCredentials(template.name);
                }
                else {
                    for (const key of Object.keys(template.auth)) {
                        const desc = template.auth[key].description;
                        if (desc !== undefined) {
                            logger.info(desc);
                        }
                        this.authProfiles[key] = yield askForCredentials(key);
                    }
                }
            }
            for (const bundle of template.bundles || []) {
                try {
                    let credentials = this.credentials;
                    if (bundle.auth === true) {
                        const key = bundle.url;
                        if (this.authProfiles[key]) {
                            credentials = this.authProfiles[key];
                        }
                        else {
                            credentials = yield askForCredentials(key);
                            this.authProfiles[key] = credentials;
                        }
                    }
                    else if (typeof bundle.auth === 'string') {
                        const key = bundle.auth;
                        if (this.authProfiles[key]) {
                            credentials = this.authProfiles[key];
                        }
                        else {
                            credentials = yield askForCredentials(key);
                            this.authProfiles[key] = credentials;
                        }
                    }
                    const file = yield downloadBundle(bundle, credentials, undefined, options, template.bundles || [], this.authProfiles);
                    if (file) {
                        yield this.executePostCommands(bundle, file);
                    }
                }
                catch (e) {
                    throw new CreateError(e.message);
                }
            }
            yield handleLightModulesFolder();
            yield initializeNodeProject();
            if (template.plugins) {
                yield installAdditionalPlugins(template.plugins);
            }
            yield handleLightModulesPathInTemplate(template);
            if (template.configVars) {
                yield addConfigProps(template.configVars);
            }
            const extensions = yield evaluateCustomPrompts(extensionsPath);
            if (extensions === null || extensions === void 0 ? void 0 : extensions.answers) {
                yield compileCustomPrompts(extensions === null || extensions === void 0 ? void 0 : extensions.answers);
            }
            if (extensions === null || extensions === void 0 ? void 0 : extensions.executePostCommands) {
                yield extensions.executePostCommands(extensions === null || extensions === void 0 ? void 0 : extensions.answers);
            }
        });
    }
    setProjectTemplates(options, originalCwd) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            let errorMsg;
            try {
                if ((_a = options.projectTemplates) === null || _a === void 0 ? void 0 : _a.startsWith('http', 0)) {
                    errorMsg = i18nInstance.t('error-no-projectTemplates-from-url', { url: options.projectTemplates });
                    const res = yield axios.get(options.projectTemplates);
                    this.projectTemplates = res.data.projectTemplates;
                }
                else if (options.projectTemplates) {
                    const projectTemplatesPath = path.resolve(originalCwd, options.projectTemplates);
                    if (!fs.existsSync(projectTemplatesPath)) {
                        throw new CreateError(i18nInstance.t('error-projectTemplates-file-not-found', { path: projectTemplatesPath }));
                    }
                    errorMsg = i18nInstance.t('error-no-projectTemplates-from-path', { path: projectTemplatesPath });
                    this.projectTemplates =
                        requireFn(projectTemplatesPath).projectTemplates;
                }
                else {
                    errorMsg = i18nInstance.t('error-no-projectTemplates-from-default');
                    const res = yield axios.get('https://gitlab.magnolia-platform.com/magnolia-cli/plugins/cli-project-templates/-/raw/main/projectTemplates.json');
                    this.projectTemplates = res.data.projectTemplates;
                }
            }
            catch (e) {
                if (e instanceof CreateError) {
                    throw e;
                }
                else if (errorMsg) {
                    throw new CreateError(errorMsg + `\n${e.message}`);
                }
                else {
                    // eslint-disable-next-line no-console
                    console.error(i18nInstance.t('error-while-getting-projectTemplates'));
                    throw e;
                }
            }
        });
    }
    promptTemplateSelection(templates_1) {
        return __awaiter(this, arguments, void 0, function* (templates, names = []) {
            if (!templates || !templates.length) {
                return;
            }
            const choices = templates.map((template) => {
                return {
                    name: `${template.name}${template.description ? ` (${template.description})` : ''}`,
                    value: template,
                };
            });
            let { template } = yield inquirer.prompt([
                {
                    type: 'list',
                    name: 'template',
                    message: i18nInstance.t('inquirer-prompt-choose-template'),
                    choices: prependNumbersToChoices(choices),
                },
            ]);
            template = Object.assign({ name: template.name }, template.value);
            if (template.name) {
                names.push(template.name);
            }
            if (template.children && template.children.length) {
                return this.promptTemplateSelection(template.children, names);
            }
            if (template.bundles || template.plugins) {
                return Object.assign(Object.assign({}, template), { name: names.join('/') });
            }
        });
    }
    findTemplateByIdentifier(identifier) {
        if (!this.projectTemplates)
            return;
        let currentTemplates = this.projectTemplates;
        for (const segment of identifier.split('/')) {
            const foundTemplate = currentTemplates.find((template) => template.name === segment);
            if (!foundTemplate)
                return;
            if (foundTemplate.bundles || foundTemplate.plugins)
                return foundTemplate;
            currentTemplates = foundTemplate.children;
        }
    }
    chooseTemplate(options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.projectTemplates)
                return;
            if (typeof options.template === 'string') {
                const template = this.findTemplateByIdentifier(options.template);
                if (template) {
                    yield this.handleTemplate(template, options);
                    return;
                }
                else {
                    logger === null || logger === void 0 ? void 0 : logger.info(i18nInstance.t('info-template-not-found', {
                        template: options.template,
                    }));
                }
            }
            const template = yield this.promptTemplateSelection(this.projectTemplates);
            if (template) {
                yield this.handleTemplate(template, options);
            }
        });
    }
    extractProjectName(args) {
        if (!Array.isArray(args)) {
            const argv = process.argv;
            if (argv.length > 3) {
                const jumpstartIndex = argv.findIndex((arg) => arg === 'jumpstart');
                if (jumpstartIndex !== -1 && argv.length > jumpstartIndex + 1) {
                    const nextArg = argv[jumpstartIndex + 1];
                    if (nextArg && !nextArg.startsWith('-')) {
                        return nextArg;
                    }
                }
            }
        }
        else if (Array.isArray(args) && args.length > 0) {
            return args[0];
        }
        return undefined;
    }
    validateAndGetDirectoryName(projectName) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!projectName) {
                return undefined;
            }
            const sanitizedName = filenamify(projectName, { replacement: '' });
            if (sanitizedName !== projectName || sanitizedName.trim() === '') {
                logger === null || logger === void 0 ? void 0 : logger.warn(i18nInstance.t('warn-invalid-directory-name', {
                    name: projectName,
                }));
                const { validDirectoryName } = yield inquirer.prompt([
                    {
                        type: 'input',
                        name: 'validDirectoryName',
                        message: i18nInstance.t('prompt-enter-valid-directory-name'),
                        validate: (input) => {
                            if (!input || input.trim() === '') {
                                return i18nInstance.t('error-directory-name-required');
                            }
                            const sanitized = filenamify(input, {
                                replacement: '',
                            });
                            if (sanitized !== input || sanitized.trim() === '') {
                                return i18nInstance.t('error-directory-name-invalid');
                            }
                            return true;
                        },
                        default: sanitizedName || 'my-magnolia-project',
                    },
                ]);
                return validDirectoryName;
            }
            return projectName;
        });
    }
    handleProjectDirectory(projectName) {
        if (!projectName) {
            logger === null || logger === void 0 ? void 0 : logger.info(i18nInstance.t('info-will-be-in-cwd'));
            return process.cwd();
        }
        const targetDir = path.resolve(projectName);
        const dirExists = fs.existsSync(targetDir);
        if (!dirExists) {
            fs.mkdirSync(targetDir, { recursive: true });
            logger === null || logger === void 0 ? void 0 : logger.info(i18nInstance.t('info-directory-created', {
                directory: projectName,
            }));
            logger === null || logger === void 0 ? void 0 : logger.info(i18nInstance.t('info-project-will-be-in-directory', {
                directory: projectName,
            }));
        }
        else {
            const files = fs.readdirSync(targetDir);
            if (files.length === 0) {
                logger === null || logger === void 0 ? void 0 : logger.info(i18nInstance.t('info-directory-exists-empty', {
                    directory: projectName,
                }));
                logger === null || logger === void 0 ? void 0 : logger.info(i18nInstance.t('info-project-will-be-in-directory', {
                    directory: projectName,
                }));
            }
            else {
                logger === null || logger === void 0 ? void 0 : logger.info(i18nInstance.t('info-directory-exists-contains-files', {
                    directory: projectName,
                }));
                logger === null || logger === void 0 ? void 0 : logger.info(i18nInstance.t('info-project-will-be-in-directory', {
                    directory: projectName,
                }));
            }
        }
        return targetDir;
    }
    init(winstonLogger) {
        return __awaiter(this, void 0, void 0, function* () {
            logger = winstonLogger;
        });
    }
    start(options, args) {
        return __awaiter(this, void 0, void 0, function* () {
            checkFlagsValue(this.options, options);
            const projectName = this.extractProjectName(args);
            const validatedProjectName = yield this.validateAndGetDirectoryName(projectName);
            const targetDir = this.handleProjectDirectory(validatedProjectName);
            const originalCwd = process.cwd();
            if (targetDir !== originalCwd) {
                process.chdir(targetDir);
            }
            try {
                yield this.setProjectTemplates(options, originalCwd);
                yield this.chooseTemplate(options);
                logger === null || logger === void 0 ? void 0 : logger.info(i18nInstance.t('info-project-downloaded'));
                logger === null || logger === void 0 ? void 0 : logger.info(i18nInstance.t('info-registered-commands'));
                logger === null || logger === void 0 ? void 0 : logger.info(i18nInstance.t('info-start-project'));
                logger === null || logger === void 0 ? void 0 : logger.info(i18nInstance.t('info-add-plugin-plugin'));
                logger === null || logger === void 0 ? void 0 : logger.info(i18nInstance.t('info-refer-to-documentation'));
            }
            finally {
                if (targetDir !== originalCwd) {
                    process.chdir(originalCwd);
                }
            }
        });
    }
    stop() {
        return __awaiter(this, void 0, void 0, function* () { });
    }
}
