var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import fs from 'fs-extra';
import parser from '@babel/parser';
import t from '@babel/types';
const generate = _generate.default;
const traverse = _traverse.default;
import beautifyModule from 'js-beautify';
import path from 'path';
import { determinePackageManager, installCLI } from './helper.js';
import ora from 'ora';
import { i18nInstance, logger } from '../jumpstart-plugin.js';
import _generate from '@babel/generator';
import _traverse from '@babel/traverse';
import { execa } from 'execa';
import JSON5 from 'json5';
import { BEAUTIFY_OPTIONS } from '@magnolia/cli-helper/general-utils';
const { js_beautify } = beautifyModule;
import { getMgnlConfigPath } from '@magnolia/cli-helper/config';
const getPackageConfigPath = () => path.join(process.cwd(), 'node_modules/@magnolia/cli/mgnl.config.js');
export const installAdditionalPlugins = (plugins) => __awaiter(void 0, void 0, void 0, function* () {
    const spinner = ora().start(i18nInstance.t('ora-start-checking-add-plugin'));
    let showManualInstallMsg = false;
    const pm = determinePackageManager();
    try {
        const addPluginExists = yield execa(pm, 'run mgnl -s -- add-plugin -v'.split(' '), { cwd: process.cwd() });
        if (addPluginExists.exitCode !== 0 ||
            !addPluginExists.stdout.match(/(\d.)+(\d).*/)) {
            spinner.warn(i18nInstance.t('ora-warn-no-add-plugin'));
            showManualInstallMsg = true;
        }
        spinner.stop();
    }
    catch (e) {
        showManualInstallMsg = true;
        spinner.fail(i18nInstance.t('ora-fail-while-add-plugin-check', {
            errorMsg: e.message,
        }));
    }
    if (showManualInstallMsg) {
        let installPluginsText = '';
        plugins.forEach((plugin) => {
            installPluginsText = `${installPluginsText} - ${plugin.plugin}\n`;
            if (plugin.pluginArgs) {
                installPluginsText = `${installPluginsText}${i18nInstance.t('text-install-plugin-with-args', { pluginArgs: JSON5.stringify(plugin.pluginArgs) })}`;
            }
        });
        logger === null || logger === void 0 ? void 0 : logger.warn(i18nInstance.t('warn-install-plugins-manually', {
            installPluginsText: installPluginsText,
        }));
        return;
    }
    for (const plugin of plugins) {
        try {
            let argsMsg;
            const addPluginArgs = `run mgnl -s -- add-plugin ${plugin.plugin}`.split(' ');
            try {
                if (plugin.pluginArgs !== undefined &&
                    plugin.pluginArgs !== 'undefined' &&
                    plugin.pluginArgs !== '') {
                    addPluginArgs.push(JSON5.stringify(JSON5.parse(JSON5.stringify(plugin.pluginArgs))));
                }
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
            }
            catch (e) {
                argsMsg = i18nInstance.t('warn-cannot-parse-plugin-args', {
                    pluginArgs: plugin.pluginArgs,
                    plugin: plugin.plugin,
                });
            }
            yield execa(pm, addPluginArgs, {
                stdio: 'inherit',
                cwd: process.cwd(),
            });
            if (argsMsg) {
                logger === null || logger === void 0 ? void 0 : logger.warn(argsMsg);
            }
        }
        catch (e) {
            logger === null || logger === void 0 ? void 0 : logger.error(i18nInstance.t('error-while-add-plugin', {
                plugin: plugin.plugin,
                errorMsg: e.message,
            }));
        }
    }
});
export const handleMGNLConfigFile = () => __awaiter(void 0, void 0, void 0, function* () {
    let isMgnlCliInstalled = true;
    if (!fs.existsSync(getPackageConfigPath())) {
        isMgnlCliInstalled = yield installCLI();
    }
    if (isMgnlCliInstalled) {
        if (fs.existsSync(getMgnlConfigPath())) {
            handleExistingConfigFile();
        }
        else {
            createMgnlConfigFile();
        }
    }
    else {
        logger === null || logger === void 0 ? void 0 : logger.error(i18nInstance.t('error-mgnl-cli-not-installed'));
    }
});
const handleExistingConfigFile = () => {
    const localConfigContent = fs.readFileSync(getMgnlConfigPath(), 'utf8');
    const packageConfigContent = fs.readFileSync(getPackageConfigPath(), 'utf8');
    const localLoggerConfig = extractLoggerConfig(localConfigContent);
    const globalLoggerConfig = extractLoggerConfig(packageConfigContent);
    if (!localLoggerConfig && globalLoggerConfig && globalLoggerConfig[1]) {
        const loggerContent = getLoggerContent(globalLoggerConfig[1]);
        const newLocalConfigContent = localConfigContent.replace(/(export\s+default\s+\{)/, `$1${loggerContent}`);
        writeConfigContent(newLocalConfigContent, false);
    }
};
function createMgnlConfigFile() {
    const packageConfigContent = fs.readFileSync(getPackageConfigPath(), 'utf8');
    const loggerConfig = extractLoggerConfig(packageConfigContent);
    const mgnlConfigPrefix = `
    export default {`;
    const logger = loggerConfig && loggerConfig[1]
        ? getLoggerContent(loggerConfig[1])
        : '';
    const mgnlConfigSufix = `
    // Here you can add plugins you want to use with MGNL CLI
    plugins: []
    };`;
    const mgnlConfigContent = mgnlConfigPrefix + logger + mgnlConfigSufix;
    writeConfigContent(mgnlConfigContent, true);
}
function getLoggerContent(logger) {
    return `
    // Logger configuration
    // see: https://github.com/winstonjs/winston#logging for logging levels explanation
    ${logger},`;
}
const extractLoggerConfig = (content) => {
    const loggerRegex = /(logger\s*:\s*{[^}]*})/;
    return loggerRegex.exec(content);
};
const writeConfigContent = (content, creating) => {
    const spinner = ora().start(i18nInstance.t(creating
        ? 'ora-start-creating-config'
        : 'ora-start-updating-config'));
    try {
        fs.writeFileSync(getMgnlConfigPath(), js_beautify(content.trim(), BEAUTIFY_OPTIONS), 'utf-8');
        spinner.succeed(i18nInstance.t(creating
            ? 'ora-succeed-config-created'
            : 'ora-succeed-config-updated'));
    }
    catch (e) {
        spinner.fail(i18nInstance.t(creating
            ? 'ora-fail-creating-config'
            : 'ora-fail-updating-config', { errorMsg: e.message }));
    }
};
export const addConfigProps = (vars) => __awaiter(void 0, void 0, void 0, function* () {
    const spinner = ora().start(i18nInstance.t('ora-start-adding-shared-vars'));
    try {
        const filePath = getMgnlConfigPath();
        const content = fs.readFileSync(filePath, 'utf-8');
        const valueToAstNode = (value) => {
            if (typeof value === 'string') {
                return t.stringLiteral(value);
            }
            else if (typeof value === 'boolean') {
                return t.booleanLiteral(value);
            }
            else if (typeof value === 'number') {
                return t.numericLiteral(value);
            }
            else if (Array.isArray(value)) {
                return t.arrayExpression(value.map((item) => valueToAstNode(item)));
            }
            else if (typeof value === 'object') {
                return t.objectExpression(Object.entries(value).map(([key, val]) => t.objectProperty(t.isValidIdentifier(key)
                    ? t.identifier(key)
                    : t.stringLiteral(key), valueToAstNode(val))));
            }
            else {
                throw new TypeError('Unsupported type');
            }
        };
        const ast = parser.parse(content, {
            sourceType: 'module',
            plugins: ['typescript'], // if you're using TypeScript
            attachComment: true,
        });
        let modificationsMade = false;
        traverse(ast, {
            ExportDefaultDeclaration({ node }) {
                if (t.isObjectExpression(node.declaration)) {
                    // Check each required property to see if it exists in the declaration
                    Object.entries(vars).forEach(([key, value]) => {
                        const propExists = node.declaration.properties.some((property) => t.isObjectProperty(property) &&
                            ((t.isIdentifier(property.key) &&
                                property.key.name === key) ||
                                (t.isStringLiteral(property.key) &&
                                    property.key.value === key)));
                        if (!propExists) {
                            // If the property doesn't exist, add it
                            node.declaration.properties.push(t.objectProperty(t.isValidIdentifier(key)
                                ? t.identifier(key)
                                : t.stringLiteral(key), valueToAstNode(value)));
                            modificationsMade = true;
                        }
                    });
                }
            },
        });
        if (modificationsMade) {
            const output = generate(ast, {}, content);
            fs.writeFileSync(getMgnlConfigPath(), js_beautify(output.code.trim(), BEAUTIFY_OPTIONS), 'utf-8');
            spinner.succeed(i18nInstance.t('ora-succeed-shared-vars-added'));
        }
    }
    catch (e) {
        spinner.fail(i18nInstance.t('error-while-adding-vars', { errorMsg: e.message }));
    }
});
