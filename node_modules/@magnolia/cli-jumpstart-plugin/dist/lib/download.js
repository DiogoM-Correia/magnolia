var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import path from 'path';
import fs from 'fs-extra';
import ProgressBar from 'progress';
import inquirer from 'inquirer';
import { i18nInstance, logger } from '../jumpstart-plugin.js';
import { askForCredentials } from './helper.js';
import axios from 'axios';
import { CreateError, prependNumbersToChoices, } from '@magnolia/cli-helper/general-utils';
import { HttpsProxyAgent } from 'https-proxy-agent';
import { HttpProxyAgent } from 'http-proxy-agent';
let discoveredMagnoliaVersion = null;
const constructMavenSearchUrl = (bundle, options, isTomcatExcluded = false) => {
    const bundleCopy = Object.assign({}, bundle);
    const url = new URL(bundleCopy.url);
    url.searchParams.set('prerelease', 'false');
    url.searchParams.set('maven.classifier', '');
    if (bundleCopy.version) {
        if (options.snapshot ||
            bundleCopy.version.toLowerCase().includes('snapshot')) {
            url.searchParams.set('prerelease', 'true');
            if (options.magnolia === undefined &&
                !bundleCopy.version.match(/^\d/)) {
                options.magnolia = '6.3';
            }
        }
        if (options.magnolia &&
            (!isTomcatExcluded ||
                !bundle.url.includes('magnolia-tomcat-barebone'))) {
            bundleCopy.version = options.magnolia;
        }
        if ((bundleCopy.version.startsWith('latest') ||
            bundleCopy.version.startsWith('6.3') ||
            bundleCopy.version.startsWith('6.4') ||
            bundleCopy.version.includes('alpha') ||
            bundleCopy.version.includes('beta') ||
            bundleCopy.version.includes('rc')) &&
            bundleCopy.alternative) {
            url.searchParams.set('maven.groupId', bundleCopy.alternative.groupId);
            url.searchParams.set('maven.artifactId', bundleCopy.alternative.artifactId);
        }
        if (bundleCopy.version.toLowerCase() !== 'latest' &&
            bundleCopy.version.toLowerCase() !== 'alpha' &&
            bundleCopy.version.toLowerCase() !== 'beta' &&
            bundleCopy.version.toLowerCase() !== 'rc') {
            url.searchParams.set('maven.baseVersion', options.snapshot
                ? bundleCopy.version + '-SNAPSHOT'
                : bundleCopy.version);
        }
    }
    return { url, modifiedBundle: bundleCopy };
};
const findItemFromResponse = (response, version) => {
    let item = response.data.items[0];
    if ((version === null || version === void 0 ? void 0 : version.toLowerCase()) === 'latest') {
        item = response.data.items.find((item) => {
            var _a;
            const itemVersion = (_a = item === null || item === void 0 ? void 0 : item.maven2) === null || _a === void 0 ? void 0 : _a.version;
            return (!(itemVersion === null || itemVersion === void 0 ? void 0 : itemVersion.includes('-alpha')) &&
                !(itemVersion === null || itemVersion === void 0 ? void 0 : itemVersion.includes('-beta')) &&
                !(itemVersion === null || itemVersion === void 0 ? void 0 : itemVersion.includes('-rc')));
        });
    }
    else if ((version === null || version === void 0 ? void 0 : version.toLowerCase()) === 'alpha') {
        item = response.data.items.find((item) => {
            var _a;
            const itemVersion = (_a = item === null || item === void 0 ? void 0 : item.maven2) === null || _a === void 0 ? void 0 : _a.version;
            return itemVersion === null || itemVersion === void 0 ? void 0 : itemVersion.includes('-alpha');
        });
    }
    else if ((version === null || version === void 0 ? void 0 : version.toLowerCase()) === 'beta') {
        item = response.data.items.find((item) => {
            var _a;
            const itemVersion = (_a = item === null || item === void 0 ? void 0 : item.maven2) === null || _a === void 0 ? void 0 : _a.version;
            return itemVersion === null || itemVersion === void 0 ? void 0 : itemVersion.includes('-beta');
        });
    }
    else if ((version === null || version === void 0 ? void 0 : version.toLowerCase()) === 'rc') {
        item = response.data.items.find((item) => {
            var _a;
            const itemVersion = (_a = item === null || item === void 0 ? void 0 : item.maven2) === null || _a === void 0 ? void 0 : _a.version;
            return itemVersion === null || itemVersion === void 0 ? void 0 : itemVersion.includes('-rc');
        });
    }
    return item;
};
const fetchMavenArtifact = (bundle_1, options_1, credentials_1, ...args_1) => __awaiter(void 0, [bundle_1, options_1, credentials_1, ...args_1], void 0, function* (bundle, options, credentials, isTomcatExcluded = false, authProfiles) {
    const opts = {
        method: 'get',
        responseType: 'json',
        headers: {
            Accept: 'application/json',
        },
    };
    const { url, modifiedBundle } = constructMavenSearchUrl(bundle, options, isTomcatExcluded);
    let resolvedCredentials = credentials;
    let profileKey;
    if (bundle.auth === true) {
        profileKey = modifiedBundle.url;
        if (authProfiles && profileKey && authProfiles[profileKey]) {
            resolvedCredentials = authProfiles[profileKey];
        }
        else {
            const promptKey = profileKey || modifiedBundle.url;
            resolvedCredentials = yield askForCredentials(promptKey);
        }
    }
    else if (typeof bundle.auth === 'string') {
        profileKey = bundle.auth;
        if (authProfiles && authProfiles[profileKey]) {
            resolvedCredentials = authProfiles[profileKey];
        }
        else {
            resolvedCredentials = yield askForCredentials(profileKey);
        }
    }
    const response = (yield get(url.toString(), opts, resolvedCredentials, modifiedBundle.name || modifiedBundle.url));
    if (authProfiles &&
        profileKey &&
        resolvedCredentials &&
        resolvedCredentials.username &&
        resolvedCredentials.password) {
        authProfiles[profileKey] = resolvedCredentials;
    }
    const item = findItemFromResponse(response, modifiedBundle.version);
    return { item, modifiedBundle };
});
const getMagnoliaVersionFromBundle = (bundle, options, credentials, authProfiles) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    try {
        const { item } = yield fetchMavenArtifact(bundle, options, credentials, false, authProfiles);
        if ((_a = item === null || item === void 0 ? void 0 : item.maven2) === null || _a === void 0 ? void 0 : _a.version) {
            return item.maven2.version;
        }
        return null;
    }
    catch (_b) {
        return null;
    }
});
const modifyTomcatBundleUrl = (bundle, allBundles, credentials, options, authProfiles) => __awaiter(void 0, void 0, void 0, function* () {
    if (!bundle.url.includes('magnolia-tomcat-barebone')) {
        return bundle;
    }
    if (discoveredMagnoliaVersion) {
        return updateTomcatBundleUrl(bundle, discoveredMagnoliaVersion);
    }
    if (allBundles && options) {
        for (const otherBundle of allBundles) {
            if (isMagnoliaBundle(otherBundle)) {
                const magnoliaVersion = yield getMagnoliaVersionFromBundle(otherBundle, options, credentials, authProfiles);
                if (magnoliaVersion === null) {
                    throw new Error(i18nInstance.t('error-no-artifact-available', {
                        version: options.magnolia || otherBundle.version,
                    }));
                }
                if (magnoliaVersion) {
                    discoveredMagnoliaVersion = magnoliaVersion;
                    return updateTomcatBundleUrl(bundle, magnoliaVersion);
                }
            }
        }
    }
    return bundle;
});
const isMagnoliaBundle = (bundle) => {
    return (bundle.url.includes('maven.groupId=info.magnolia') &&
        !bundle.url.includes('magnolia-tomcat-barebone'));
};
const updateTomcatBundleUrl = (bundle, magnoliaVersion) => {
    const versionParts = magnoliaVersion.split('.');
    const majorVersion = parseInt(versionParts[0]);
    const minorVersion = parseInt(versionParts[1]);
    let baseVersion = '1.*'; // Default for 6.3 and below
    if (majorVersion > 6 || (majorVersion === 6 && minorVersion >= 4)) {
        baseVersion = '2.*';
    }
    // Change the version only if the version isn't set in projectTemplates
    if (!bundle.url.includes('maven.baseVersion=') || bundle.version) {
        bundle.url = `${bundle.url}&maven.baseVersion=${baseVersion}`;
    }
    return bundle;
};
export const downloadBundle = (bundle, credentials, dest, options, allBundles, authProfiles) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const url = bundle.url;
        const downloadDest = dest ? dest : './download-' + new Date().getTime();
        let downloadUrl;
        if (path.parse(url).name === 'tags') {
            downloadUrl = yield selectTag(url, credentials);
        }
        else if (url.includes('https://nexus.magnolia-cms.com/service/rest/v1/search') ||
            url.includes('https://nexus.magnolia-cms.cn/service/rest/v1/search')) {
            logger === null || logger === void 0 ? void 0 : logger.info(i18nInstance.t('info-download-preparing', {
                url,
            }));
            const modifiedBundle = yield modifyTomcatBundleUrl(bundle, allBundles, credentials, options, authProfiles);
            downloadUrl = yield getDownloadUrl(modifiedBundle, credentials, options, authProfiles);
        }
        else {
            downloadUrl = url;
        }
        const opts = {
            method: 'get',
            responseType: 'stream',
        };
        if (downloadDest) {
            yield fs.ensureDir(downloadDest);
        }
        const parsedUrl = new URL(downloadUrl);
        const filename = path.basename(parsedUrl.pathname);
        const tempDownload = path.join(downloadDest, bundle.name || filename || 'temp-' + new Date().getTime());
        const target = fs.createWriteStream(tempDownload);
        logger === null || logger === void 0 ? void 0 : logger.info(i18nInstance.t('info-download-starting', {
            downloadUrl: downloadUrl,
        }));
        const res = yield get(downloadUrl, opts, credentials, bundle.name || bundle.url);
        if (res.status !== 200) {
            throw new Error(i18nInstance.t('error-download-fail-status', {
                downloadUrl: downloadUrl,
                status: res.status,
            }));
        }
        if (res.headers['content-length']) {
            const len = parseInt(res.headers['content-length'], 10);
            const bar = new ProgressBar(`${i18nInstance.t('progress-bar-downloading')} [:bar] :percent :etas`, {
                complete: '=',
                incomplete: ' ',
                width: 20,
                total: len,
            });
            res.data.on('data', (chunk) => {
                bar.tick(chunk.length);
            });
        }
        res.data.pipe(target);
        return new Promise((resolve) => {
            target.on('finish', () => {
                resolve(path.join('.', tempDownload));
            });
            target.on('error', (error) => {
                target.close();
                throw new Error(error);
            });
            res.data.on('error', (error) => {
                target.close();
                throw new Error(error);
            });
        });
    }
    catch (error) {
        logger === null || logger === void 0 ? void 0 : logger.error(i18nInstance.t('error-while-downloading-bundle', {
            url: bundle.url,
        }));
        throw new CreateError(error.message);
    }
});
export const getDownloadUrl = (bundle, credentials, options, authProfiles) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b, _c;
    try {
        const { item, modifiedBundle } = yield fetchMavenArtifact(bundle, options, credentials, true, authProfiles);
        bundle.version = modifiedBundle.version;
        if (!item) {
            throw new Error(i18nInstance.t('error-no-artifact-available', {
                version: bundle.version,
            }));
        }
        bundle.version = (_b = (_a = item === null || item === void 0 ? void 0 : item.maven2) === null || _a === void 0 ? void 0 : _a.version) !== null && _b !== void 0 ? _b : bundle.version;
        if (isMagnoliaBundle(bundle) && ((_c = item === null || item === void 0 ? void 0 : item.maven2) === null || _c === void 0 ? void 0 : _c.version)) {
            discoveredMagnoliaVersion = item.maven2.version;
        }
        return item.downloadUrl;
    }
    catch (error) {
        if (error.code === 'UNABLE_TO_GET_ISSUER_CERT_LOCALLY') {
            logger === null || logger === void 0 ? void 0 : logger.error(i18nInstance.t('error-problem-accessing-url', {
                url: bundle.url,
            }));
            logger === null || logger === void 0 ? void 0 : logger.error(i18nInstance.t('error-unable-to-get-local-issuer-certificate'));
        }
        throw new CreateError(error.message);
    }
});
export const selectTag = (url, credentials) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    const opts = {
        method: 'get',
        headers: {
            Accept: 'application/json',
        },
    };
    const res = (yield get(url, opts, credentials));
    if (!((_a = res.data) === null || _a === void 0 ? void 0 : _a.values) || res.data.values.length <= 0) {
        throw new CreateError(i18nInstance.t('error-no-tags'));
    }
    const { tag } = yield inquirer.prompt([
        {
            type: 'list',
            name: 'tag',
            message: i18nInstance.t('inquirer-prompt-select-tag'),
            choices: prependNumbersToChoices(res.data.values.map((tag) => ({
                name: tag.displayId,
                value: 'archive?at=' + tag.id,
            }))),
        },
    ]);
    return url.slice(0, url.length - 4) + tag;
});
function get(url, opts, credentials, bundleName) {
    return __awaiter(this, void 0, void 0, function* () {
        let res;
        if (bundleName === undefined) {
            bundleName = url;
        }
        if (credentials) {
            opts.auth = credentials;
        }
        opts = setProxyOpts(opts);
        const handleAuthFail = () => __awaiter(this, void 0, void 0, function* () {
            logger === null || logger === void 0 ? void 0 : logger.error(i18nInstance.t('error-auth-fail', { url }));
            if (credentials) {
                opts.auth = yield askForCredentials(bundleName);
                credentials.username = opts.auth.username;
                credentials.password = opts.auth.password;
            }
        });
        while (true) {
            try {
                res = yield axios.get(url, opts);
                if (res.status === 401 && credentials) {
                    yield handleAuthFail();
                }
                else {
                    break;
                }
            }
            catch (e) {
                if (e.response.status === 401 && credentials) {
                    yield handleAuthFail();
                }
                else {
                    throw Error(e);
                }
            }
        }
        return res;
    });
}
const setProxyOpts = (opts) => {
    const httpsproxy = process.env.https_proxy || process.env.HTTPS_PROXY;
    const httpproxy = process.env.http_proxy || process.env.HTTP_PROXY;
    if (httpsproxy) {
        return Object.assign(Object.assign({}, opts), { httpsAgent: new HttpsProxyAgent(httpsproxy), proxy: false });
    }
    else if (httpproxy) {
        return Object.assign(Object.assign({}, opts), { httpAgent: new HttpProxyAgent(httpproxy), proxy: false });
    }
    return opts;
};
