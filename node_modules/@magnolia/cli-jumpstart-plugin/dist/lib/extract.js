var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import decompress from 'decompress';
import path from 'path';
import walk from 'walk';
import fs from 'fs-extra';
import { PostCommands } from '../types/types.js';
import url from 'url';
import { i18nInstance, logger } from '../jumpstart-plugin.js';
import { handleMicroprofileConfig } from './handleMicroprofileConfig.js';
import ora from 'ora';
import { CreateError } from '@magnolia/cli-helper/general-utils';
export const extract = (bundle, file, command) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    const spinner = ora().start(i18nInstance.t('ora-start-extracting'));
    let { dest = './' } = bundle;
    try {
        const unzipFolder = 'temp-' + new Date().getTime();
        yield decompress(file, unzipFolder);
        if (command === PostCommands.ExtractAndOverride) {
            fs.rmSync(dest, { recursive: true, force: true });
        }
        const artifactId = (_a = url.parse(bundle.url, true)) === null || _a === void 0 ? void 0 : _a.query['maven.artifactId'];
        if (artifactId === 'magnolia-tomcat-barebone') {
            dest = path.join(dest, 'apache-tomcat');
            yield extractApacheTomcat(dest, unzipFolder);
            spinner.succeed(i18nInstance.t('ora-succeed-extracted-to', {
                path: path.resolve(dest),
            }));
        }
        else {
            let sourceFolder = unzipFolder;
            if (command === PostCommands.ExtractAndUnfold) {
                const firstDir = fs.readdirSync(unzipFolder).find((item) => {
                    const itemPath = path.join(unzipFolder, item);
                    return fs.statSync(itemPath).isDirectory();
                });
                sourceFolder = firstDir
                    ? path.join(unzipFolder, firstDir)
                    : unzipFolder;
            }
            fs.copySync(sourceFolder, dest, { overwrite: true });
            spinner.succeed(i18nInstance.t('ora-succeed-extracted-to', {
                path: path.resolve(dest),
            }));
            yield handleMicroprofileConfig(bundle, dest);
        }
        fs.rmSync(unzipFolder, { recursive: true, force: true });
        fs.rmSync(path.dirname(file), { recursive: true, force: true });
    }
    catch (e) {
        spinner.stop();
        logger === null || logger === void 0 ? void 0 : logger.error(i18nInstance.t('error-extraction-fail', { error: e.message }));
        process.exit(1);
    }
});
export const extractApacheTomcat = (dest, unzipFolder) => __awaiter(void 0, void 0, void 0, function* () {
    const apacheTomcatDir = yield findExtractedApacheTomcatDir(unzipFolder);
    fs.rmSync(path.join(apacheTomcatDir, 'webapps', 'magnoliaAuthor'), {
        recursive: true,
        force: true,
    });
    fs.copySync(apacheTomcatDir, dest, { overwrite: false });
});
export const findExtractedApacheTomcatDir = (p) => {
    return new Promise((resolve, reject) => {
        const walker = walk.walk(p, { followLinks: false });
        walker.on('directory', (root, { name }, next) => {
            if (name.match(/(apache-tomcat).*/)) {
                resolve(path.join(root, name));
            }
            next();
        });
        walker.on('end', function () {
            return reject(new CreateError(i18nInstance.t('error-apache-tomcat-not-found')));
        });
    });
};
